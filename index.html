<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Module chipmunk</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #666;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0.25em 10px 0.25em 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */

ul.simple > li {
  margin-bottom: 0.5em }

ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
</style>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Module chipmunk</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#Float"
    title="Float* = cdouble"><wbr />Float</a></li>
  <li><a class="reference" href="#HashValue"
    title="HashValue* = pointer"><wbr />Hash<wbr />Value</a></li>
  <li><a class="reference" href="#CollisionID"
    title="CollisionID* = uint32"><wbr />Collision<wbr />ID</a></li>
  <li><a class="reference" href="#DataPointer"
    title="DataPointer* = pointer"><wbr />Data<wbr />Pointer</a></li>
  <li><a class="reference" href="#CollisionType"
    title="CollisionType* = pointer"><wbr />Collision<wbr />Type</a></li>
  <li><a class="reference" href="#Group"
    title="Group* = pointer"><wbr />Group</a></li>
  <li><a class="reference" href="#Bitmask"
    title="Bitmask* = cuint"><wbr />Bitmask</a></li>
  <li><a class="reference" href="#Timestamp"
    title="Timestamp* = cuint"><wbr />Timestamp</a></li>
  <li><a class="reference" href="#Vect"
    title="Vect* = object
  x*: Float
  y*: Float"><wbr />Vect</a></li>
  <li><a class="reference" href="#Transform"
    title="Transform* = object
  a*: Float
  b*: Float
  c*: Float
  d*: Float
  tx*: Float
  ty*: Float"><wbr />Transform</a></li>
  <li><a class="reference" href="#Mat2x2"
    title="Mat2x2* = object
  a*: Float
  b*: Float
  c*: Float
  d*: Float"><wbr />Mat2x2</a></li>
  <li><a class="reference" href="#Array"
    title="Array* = ptr object"><wbr />Array</a></li>
  <li><a class="reference" href="#HashSet"
    title="HashSet* = ptr object"><wbr />Hash<wbr />Set</a></li>
  <li><a class="reference" href="#Body"
    title="Body* = ptr object"><wbr />Body</a></li>
  <li><a class="reference" href="#Shape"
    title="Shape* = ptr ShapeObj"><wbr />Shape</a></li>
  <li><a class="reference" href="#CircleShape"
    title="CircleShape* = ptr object of Shape"><wbr />Circle<wbr />Shape</a></li>
  <li><a class="reference" href="#SegmentShape"
    title="SegmentShape* = ptr object of Shape"><wbr />Segment<wbr />Shape</a></li>
  <li><a class="reference" href="#PolyShape"
    title="PolyShape* = ptr object of Shape"><wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#Constraint"
    title="Constraint* = ptr ConstraintObj"><wbr />Constraint</a></li>
  <li><a class="reference" href="#PinJoint"
    title="PinJoint* = ptr object of Constraint"><wbr />Pin<wbr />Joint</a></li>
  <li><a class="reference" href="#SlideJoint"
    title="SlideJoint* = ptr object of Constraint"><wbr />Slide<wbr />Joint</a></li>
  <li><a class="reference" href="#PivotJoint"
    title="PivotJoint* = ptr object of Constraint"><wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#GrooveJoint"
    title="GrooveJoint* = ptr object of Constraint"><wbr />Groove<wbr />Joint</a></li>
  <li><a class="reference" href="#DampedSpring"
    title="DampedSpring* = ptr object of Constraint"><wbr />Damped<wbr />Spring</a></li>
  <li><a class="reference" href="#DampedRotarySpring"
    title="DampedRotarySpring* = ptr object of Constraint"><wbr />Damped<wbr />Rotary<wbr />Spring</a></li>
  <li><a class="reference" href="#RotaryLimitJoint"
    title="RotaryLimitJoint* = ptr object of Constraint"><wbr />Rotary<wbr />Limit<wbr />Joint</a></li>
  <li><a class="reference" href="#RatchetJoint"
    title="RatchetJoint* = ptr object of Constraint"><wbr />Ratchet<wbr />Joint</a></li>
  <li><a class="reference" href="#GearJoint"
    title="GearJoint* = ptr object of Constraint"><wbr />Gear<wbr />Joint</a></li>
  <li><a class="reference" href="#SimpleMotorJoint"
    title="SimpleMotorJoint* = ptr object"><wbr />Simple<wbr />Motor<wbr />Joint</a></li>
  <li><a class="reference" href="#Arbiter"
    title="Arbiter* = ptr object"><wbr />Arbiter</a></li>
  <li><a class="reference" href="#Space"
    title="Space* = ptr object"><wbr />Space</a></li>
  <li><a class="reference" href="#BB"
    title="BB* = object
  l*: Float
  b*: Float
  r*: Float
  t*: Float"><wbr />BB</a></li>
  <li><a class="reference" href="#SpatialIndexBBFunc"
    title="SpatialIndexBBFunc* = proc (obj: pointer): BB"><wbr />Spatial<wbr />Index<wbr />BBFunc</a></li>
  <li><a class="reference" href="#SpatialIndexIteratorFunc"
    title="SpatialIndexIteratorFunc* = proc (obj: pointer; data: pointer)"><wbr />Spatial<wbr />Index<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#SpatialIndexQueryFunc"
    title="SpatialIndexQueryFunc* = proc (obj1: pointer; obj2: pointer; id: CollisionID;
                            data: pointer): CollisionID"><wbr />Spatial<wbr />Index<wbr />Query<wbr />Func</a></li>
  <li><a class="reference" href="#SpatialIndexSegmentQueryFunc"
    title="SpatialIndexSegmentQueryFunc* = proc (obj1: pointer; obj2: pointer; data: pointer): Float"><wbr />Spatial<wbr />Index<wbr />Segment<wbr />Query<wbr />Func</a></li>
  <li><a class="reference" href="#SpatialIndex"
    title="SpatialIndex* = ptr SpatialIndexObj"><wbr />Spatial<wbr />Index</a></li>
  <li><a class="reference" href="#SpaceHash"
    title="SpaceHash* = ptr object of SpatialIndex"><wbr />Space<wbr />Hash</a></li>
  <li><a class="reference" href="#BBTree"
    title="BBTree* = ptr object of SpatialIndex"><wbr />BBTree</a></li>
  <li><a class="reference" href="#BBTreeVelocityFunc"
    title="BBTreeVelocityFunc* = proc (obj: pointer): Vect"><wbr />BBTree<wbr />Velocity<wbr />Func</a></li>
  <li><a class="reference" href="#Sweep1D"
    title="Sweep1D* = ptr object of SpatialIndex"><wbr />Sweep1D</a></li>
  <li><a class="reference" href="#SpatialIndexDestroyImpl"
    title="SpatialIndexDestroyImpl* = proc (index: SpatialIndex)"><wbr />Spatial<wbr />Index<wbr />Destroy<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexCountImpl"
    title="SpatialIndexCountImpl* = proc (index: SpatialIndex): cint"><wbr />Spatial<wbr />Index<wbr />Count<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexEachImpl"
    title="SpatialIndexEachImpl* = proc (index: SpatialIndex; `func`: SpatialIndexIteratorFunc;
                           data: pointer)"><wbr />Spatial<wbr />Index<wbr />Each<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexContainsImpl"
    title="SpatialIndexContainsImpl* = proc (index: SpatialIndex; obj: pointer; hashid: HashValue): bool"><wbr />Spatial<wbr />Index<wbr />Contains<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexInsertImpl"
    title="SpatialIndexInsertImpl* = proc (index: SpatialIndex; obj: pointer; hashid: HashValue)"><wbr />Spatial<wbr />Index<wbr />Insert<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexRemoveImpl"
    title="SpatialIndexRemoveImpl* = proc (index: SpatialIndex; obj: pointer; hashid: HashValue)"><wbr />Spatial<wbr />Index<wbr />Remove<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexReindexImpl"
    title="SpatialIndexReindexImpl* = proc (index: SpatialIndex)"><wbr />Spatial<wbr />Index<wbr />Reindex<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexReindexObjectImpl"
    title="SpatialIndexReindexObjectImpl* = proc (index: SpatialIndex; obj: pointer;
                                    hashid: HashValue)"><wbr />Spatial<wbr />Index<wbr />Reindex<wbr />Object<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexReindexQueryImpl"
    title="SpatialIndexReindexQueryImpl* = proc (index: SpatialIndex;
                                   `func`: SpatialIndexQueryFunc; data: pointer)"><wbr />Spatial<wbr />Index<wbr />Reindex<wbr />Query<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexQueryImpl"
    title="SpatialIndexQueryImpl* = proc (index: SpatialIndex; obj: pointer; bb: BB;
                            `func`: SpatialIndexQueryFunc; data: pointer)"><wbr />Spatial<wbr />Index<wbr />Query<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexSegmentQueryImpl"
    title="SpatialIndexSegmentQueryImpl* = proc (index: SpatialIndex; obj: pointer; a: Vect;
                                   b: Vect; t_exit: Float;
                                   `func`: SpatialIndexSegmentQueryFunc;
                                   data: pointer)"><wbr />Spatial<wbr />Index<wbr />Segment<wbr />Query<wbr />Impl</a></li>
  <li><a class="reference" href="#SpatialIndexClass"
    title="SpatialIndexClass* = object
  destroy*: SpatialIndexDestroyImpl
  count*: SpatialIndexCountImpl
  each*: SpatialIndexEachImpl
  contains*: SpatialIndexContainsImpl
  insert*: SpatialIndexInsertImpl
  remove*: SpatialIndexRemoveImpl
  reindex*: SpatialIndexReindexImpl
  reindexObject*: SpatialIndexReindexObjectImpl
  reindexQuery*: SpatialIndexReindexQueryImpl
  query*: SpatialIndexQueryImpl
  segmentQuery*: SpatialIndexSegmentQueryImpl"><wbr />Spatial<wbr />Index<wbr />Class</a></li>
  <li><a class="reference" href="#ContactPoint"
    title="ContactPoint* = object
  pointA*: Vect
  pointB*: Vect                ## The position of the contact on the surface of each shape.
  distance*: Float ## Penetration distance of the two shapes. Overlapping means it will be negative.
                 ## This value is calculated as cpvdot(cpvsub(point2, point1), normal) and is ignored by cpArbiterSetContactPointSet()."><wbr />Contact<wbr />Point</a></li>
  <li><a class="reference" href="#ContactPointSet"
    title="ContactPointSet* = object
  count*: cint                 ## The number of contact points in the set.
  normal*: Vect                ## The normal of the collision.
  points*: array[2, ContactPoint] ## The array of contact points."><wbr />Contact<wbr />Point<wbr />Set</a></li>
  <li><a class="reference" href="#BodyType"
    title="BodyType* = enum
  BODY_TYPE_DYNAMIC, ## A dynamic body is one that is affected by gravity, forces, and collisions.
                    ## This is the default body type.
  BODY_TYPE_KINEMATIC, ## A kinematic body is an infinite mass, user controlled body that is not affected by gravity, forces or collisions.
                      ## Instead the body only moves based on it&#x27;s velocity.
                      ## Dynamic bodies collide normally with kinematic bodies, though the kinematic body will be unaffected.
                      ## Collisions between two kinematic bodies, or a kinematic body and a static body produce collision callbacks, but no collision response.
  BODY_TYPE_STATIC ## A static body is a body that never (or rarely) moves. If you move a static body, you must call one of the cpSpaceReindex*() functions.
                  ## Chipmunk uses this information to optimize the collision detection.
                  ## Static bodies do not produce collision callbacks when colliding with other static bodies."><wbr />Body<wbr />Type</a></li>
  <li><a class="reference" href="#BodyVelocityFunc"
    title="BodyVelocityFunc* = proc (body: Body; gravity: Vect; damping: Float; dt: Float)"><wbr />Body<wbr />Velocity<wbr />Func</a></li>
  <li><a class="reference" href="#BodyPositionFunc"
    title="BodyPositionFunc* = proc (body: Body; dt: Float)"><wbr />Body<wbr />Position<wbr />Func</a></li>
  <li><a class="reference" href="#BodyShapeIteratorFunc"
    title="BodyShapeIteratorFunc* = proc (body: Body; shape: Shape; data: pointer)"><wbr />Body<wbr />Shape<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#BodyConstraintIteratorFunc"
    title="BodyConstraintIteratorFunc* = proc (body: Body; constraint: Constraint; data: pointer)"><wbr />Body<wbr />Constraint<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#BodyArbiterIteratorFunc"
    title="BodyArbiterIteratorFunc* = proc (body: Body; arbiter: Arbiter; data: pointer)"><wbr />Body<wbr />Arbiter<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#PointQueryInfo"
    title="PointQueryInfo* = object
  shape*: Shape                ## The nearest shape, NULL if no shape was within range.
  point*: Vect                 ## The closest point on the shape&#x27;s surface. (in world space coordinates)
  distance*: Float             ## The distance to the point. The distance is negative if the point is inside the shape.
  gradient*: Vect              ## The gradient of the signed distance function.
                ## The value should be similar to info.p&#x2F;info.d, but accurate even for very small values of info.d."><wbr />Point<wbr />Query<wbr />Info</a></li>
  <li><a class="reference" href="#SegmentQueryInfo"
    title="SegmentQueryInfo* = object
  shape*: Shape                ## The shape that was hit, or NULL if no collision occured.
  point*: Vect                 ## The point of impact.
  normal*: Vect                ## The normal of the surface hit.
  alpha*: Float                ## The normalized distance along the query segment in the range [0, 1]."><wbr />Segment<wbr />Query<wbr />Info</a></li>
  <li><a class="reference" href="#ShapeFilter"
    title="ShapeFilter* = object
  group*: Group ## Two objects with the same non-zero group value do not collide.
              ## This is generally used to group objects in a composite object together to disable self collisions.
  categories*: Bitmask ## A bitmask of user definable categories that this object belongs to.
                     ## The category&#x2F;mask combinations of both objects in a collision must agree for a collision to occur.
  mask*: Bitmask ## A bitmask of user definable category types that this object object collides with.
               ## The category&#x2F;mask combinations of both objects in a collision must agree for a collision to occur."><wbr />Shape<wbr />Filter</a></li>
  <li><a class="reference" href="#ConstraintPreSolveFunc"
    title="ConstraintPreSolveFunc* = proc (constraint: Constraint; space: Space)"><wbr />Constraint<wbr />Pre<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#ConstraintPostSolveFunc"
    title="ConstraintPostSolveFunc* = proc (constraint: Constraint; space: Space)"><wbr />Constraint<wbr />Post<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#DampedSpringForceFunc"
    title="DampedSpringForceFunc* = proc (spring: Constraint; dist: Float): Float"><wbr />Damped<wbr />Spring<wbr />Force<wbr />Func</a></li>
  <li><a class="reference" href="#DampedRotarySpringTorqueFunc"
    title="DampedRotarySpringTorqueFunc* = proc (spring: Constraint; relativeAngle: Float): Float"><wbr />Damped<wbr />Rotary<wbr />Spring<wbr />Torque<wbr />Func</a></li>
  <li><a class="reference" href="#SimpleMotor"
    title="SimpleMotor* = ptr object of Constraint"><wbr />Simple<wbr />Motor</a></li>
  <li><a class="reference" href="#CollisionBeginFunc"
    title="CollisionBeginFunc* = proc (arb: Arbiter; space: Space; userData: DataPointer): bool"><wbr />Collision<wbr />Begin<wbr />Func</a></li>
  <li><a class="reference" href="#CollisionPreSolveFunc"
    title="CollisionPreSolveFunc* = proc (arb: Arbiter; space: Space; userData: DataPointer): bool"><wbr />Collision<wbr />Pre<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#CollisionPostSolveFunc"
    title="CollisionPostSolveFunc* = proc (arb: Arbiter; space: Space; userData: DataPointer)"><wbr />Collision<wbr />Post<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#CollisionSeparateFunc"
    title="CollisionSeparateFunc* = proc (arb: Arbiter; space: Space; userData: DataPointer)"><wbr />Collision<wbr />Separate<wbr />Func</a></li>
  <li><a class="reference" href="#CollisionHandler"
    title="CollisionHandler* = object
  typeA*: CollisionType ## Collision type identifier of the first shape that this handler recognizes.
                      ## In the collision handler callback, the shape with this type will be the first argument. Read only.
  typeB*: CollisionType ## Collision type identifier of the second shape that this handler recognizes.
                      ## In the collision handler callback, the shape with this type will be the second argument. Read only.
  beginFunc*: CollisionBeginFunc ## This function is called when two shapes with types that match this collision handler begin colliding.
  preSolveFunc*: CollisionPreSolveFunc ## This function is called each step when two shapes with types that match this collision handler are colliding.
                                     ## It&#x27;s called before the collision solver runs so that you can affect a collision&#x27;s outcome.
  postSolveFunc*: CollisionPostSolveFunc ## This function is called each step when two shapes with types that match this collision handler are colliding.
                                       ## It&#x27;s called after the collision solver runs so that you can read back information about the collision to trigger events in your game.
  separateFunc*: CollisionSeparateFunc ## This function is called when two shapes with types that match this collision handler stop colliding.
  userData*: DataPointer       ## This is a user definable context pointer that is passed to all of the collision handler functions."><wbr />Collision<wbr />Handler</a></li>
  <li><a class="reference" href="#PostStepFunc"
    title="PostStepFunc* = proc (space: Space; key: pointer; data: pointer)"><wbr />Post<wbr />Step<wbr />Func</a></li>
  <li><a class="reference" href="#SpacePointQueryFunc"
    title="SpacePointQueryFunc* = proc (shape: Shape; point: Vect; distance: Float; gradient: Vect;
                          data: pointer)"><wbr />Space<wbr />Point<wbr />Query<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceSegmentQueryFunc"
    title="SpaceSegmentQueryFunc* = proc (shape: Shape; point: Vect; normal: Vect; alpha: Float;
                            data: pointer)"><wbr />Space<wbr />Segment<wbr />Query<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceBBQueryFunc"
    title="SpaceBBQueryFunc* = proc (shape: Shape; data: pointer)"><wbr />Space<wbr />BBQuery<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceShapeQueryFunc"
    title="SpaceShapeQueryFunc* = proc (shape: Shape; points: ptr ContactPointSet; data: pointer)"><wbr />Space<wbr />Shape<wbr />Query<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceBodyIteratorFunc"
    title="SpaceBodyIteratorFunc* = proc (body: Body; data: pointer)"><wbr />Space<wbr />Body<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceShapeIteratorFunc"
    title="SpaceShapeIteratorFunc* = proc (shape: Shape; data: pointer)"><wbr />Space<wbr />Shape<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceConstraintIteratorFunc"
    title="SpaceConstraintIteratorFunc* = proc (constraint: Constraint; data: pointer)"><wbr />Space<wbr />Constraint<wbr />Iterator<wbr />Func</a></li>
  <li><a class="reference" href="#SpaceDebugColor"
    title="SpaceDebugColor* = object
  r*: cfloat
  g*: cfloat
  b*: cfloat
  a*: cfloat"><wbr />Space<wbr />Debug<wbr />Color</a></li>
  <li><a class="reference" href="#SpaceDebugDrawCircleImpl"
    title="SpaceDebugDrawCircleImpl* = proc (pos: Vect; angle: Float; radius: Float;
                               outlineColor: SpaceDebugColor;
                               fillColor: SpaceDebugColor; data: DataPointer)"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Circle<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawSegmentImpl"
    title="SpaceDebugDrawSegmentImpl* = proc (a: Vect; b: Vect; color: SpaceDebugColor;
                                data: DataPointer)"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Segment<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawFatSegmentImpl"
    title="SpaceDebugDrawFatSegmentImpl* = proc (a: Vect; b: Vect; radius: Float;
                                   outlineColor: SpaceDebugColor;
                                   fillColor: SpaceDebugColor; data: DataPointer)"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Fat<wbr />Segment<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawPolygonImpl"
    title="SpaceDebugDrawPolygonImpl* = proc (count: cint; verts: ptr Vect; radius: Float;
                                outlineColor: SpaceDebugColor;
                                fillColor: SpaceDebugColor; data: DataPointer)"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Polygon<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawDotImpl"
    title="SpaceDebugDrawDotImpl* = proc (size: Float; pos: Vect; color: SpaceDebugColor;
                            data: DataPointer)"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Dot<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawColorForShapeImpl"
    title="SpaceDebugDrawColorForShapeImpl* = proc (shape: Shape; data: DataPointer): SpaceDebugColor"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Color<wbr />For<wbr />Shape<wbr />Impl</a></li>
  <li><a class="reference" href="#SpaceDebugDrawFlags"
    title="SpaceDebugDrawFlags* = enum
  SPACE_DEBUG_DRAW_SHAPES = 1 shl 0, SPACE_DEBUG_DRAW_CONSTRAINTS = 1 shl 1,
  SPACE_DEBUG_DRAW_COLLISION_POINTS = 1 shl 2"><wbr />Space<wbr />Debug<wbr />Draw<wbr />Flags</a></li>
  <li><a class="reference" href="#SpaceDebugDrawOptions"
    title="SpaceDebugDrawOptions* = object
  drawCircle*: SpaceDebugDrawCircleImpl ## Function that will be invoked to draw circles.
  drawSegment*: SpaceDebugDrawSegmentImpl ## Function that will be invoked to draw line segments.
  drawFatSegment*: SpaceDebugDrawFatSegmentImpl ## Function that will be invoked to draw thick line segments.
  drawPolygon*: SpaceDebugDrawPolygonImpl ## Function that will be invoked to draw convex polygons.
  drawDot*: SpaceDebugDrawDotImpl ## Function that will be invoked to draw dots.
  flags*: SpaceDebugDrawFlags  ## Flags that request which things to draw (collision shapes, constraints, contact points).
  shapeOutlineColor*: SpaceDebugColor ## Outline color passed to the drawing function.
  colorForShape*: SpaceDebugDrawColorForShapeImpl ## Function that decides what fill color to draw shapes using.
  constraintColor*: SpaceDebugColor ## Color passed to drawing functions for constraints.
  collisionPointColor*: SpaceDebugColor ## Color passed to drawing functions for collision points.
  data*: DataPointer           ## User defined context pointer passed to all of the callback functions as the &#x27;data&#x27; argument."><wbr />Space<wbr />Debug<wbr />Draw<wbr />Options</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#8" id="58">Vars</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#vzero"
    title="vzero* = Vect(x: 0.0&#x27;f64, y: 0.0&#x27;f64)"><wbr />vzero</a></li>
  <li><a class="reference" href="#TransformIdentity"
    title="TransformIdentity* = Transform(a: 1.0&#x27;f64, b: 0.0&#x27;f64, c: 0.0&#x27;f64, d: 1.0&#x27;f64,
                             tx: 0.0&#x27;f64, ty: 0.0&#x27;f64)"><wbr />Transform<wbr />Identity</a></li>
  <li><a class="reference" href="#SHAPE_FILTER_ALL"
    title="SHAPE_FILTER_ALL* = ShapeFilter(group: (cast[Group](0)))"><wbr />SHAPE_<wbr />FILTER_<wbr />ALL</a></li>
  <li><a class="reference" href="#SHAPE_FILTER_NONE"
    title="SHAPE_FILTER_NONE* = ShapeFilter(group: (cast[Group](0)))"><wbr />SHAPE_<wbr />FILTER_<wbr />NONE</a></li>
  <li><a class="reference" href="#VersionString"
    title="VersionString*: cstring"><wbr />Version<wbr />String</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#message,cstring,cstring,cint,cint,cint,cstring"
    title="message*(condition: cstring; file: cstring; line: cint; isError: cint;
         isHardError: cint; message: cstring)"><wbr />message</a></li>
  <li><a class="reference" href="#fmax,Float,Float"
    title="fmax*(a: Float; b: Float): Float"><wbr />fmax</a></li>
  <li><a class="reference" href="#fmin,Float,Float"
    title="fmin*(a: Float; b: Float): Float"><wbr />fmin</a></li>
  <li><a class="reference" href="#fabs,Float"
    title="fabs*(f: Float): Float"><wbr />fabs</a></li>
  <li><a class="reference" href="#fclamp,Float,Float,Float"
    title="fclamp*(f: Float; min: Float; max: Float): Float"><wbr />fclamp</a></li>
  <li><a class="reference" href="#fclamp01,Float"
    title="fclamp01*(f: Float): Float"><wbr />fclamp01</a></li>
  <li><a class="reference" href="#flerp,Float,Float,Float"
    title="flerp*(f1: Float; f2: Float; t: Float): Float"><wbr />flerp</a></li>
  <li><a class="reference" href="#flerpconst,Float,Float,Float"
    title="flerpconst*(f1: Float; f2: Float; d: Float): Float"><wbr />flerpconst</a></li>
  <li><a class="reference" href="#v,Float,Float"
    title="v*(x: Float; y: Float): Vect"><wbr />v</a></li>
  <li><a class="reference" href="#veql,Vect,Vect"
    title="veql*(v1: Vect; v2: Vect): bool"><wbr />veql</a></li>
  <li><a class="reference" href="#vadd,Vect,Vect"
    title="vadd*(v1: Vect; v2: Vect): Vect"><wbr />vadd</a></li>
  <li><a class="reference" href="#vsub,Vect,Vect"
    title="vsub*(v1: Vect; v2: Vect): Vect"><wbr />vsub</a></li>
  <li><a class="reference" href="#vneg,Vect"
    title="vneg*(v: Vect): Vect"><wbr />vneg</a></li>
  <li><a class="reference" href="#vmult,Vect,Float"
    title="vmult*(v: Vect; s: Float): Vect"><wbr />vmult</a></li>
  <li><a class="reference" href="#vdot,Vect,Vect"
    title="vdot*(v1: Vect; v2: Vect): Float"><wbr />vdot</a></li>
  <li><a class="reference" href="#vcross,Vect,Vect"
    title="vcross*(v1: Vect; v2: Vect): Float"><wbr />vcross</a></li>
  <li><a class="reference" href="#vperp,Vect"
    title="vperp*(v: Vect): Vect"><wbr />vperp</a></li>
  <li><a class="reference" href="#vrperp,Vect"
    title="vrperp*(v: Vect): Vect"><wbr />vrperp</a></li>
  <li><a class="reference" href="#vproject,Vect,Vect"
    title="vproject*(v1: Vect; v2: Vect): Vect"><wbr />vproject</a></li>
  <li><a class="reference" href="#vforangle,Float"
    title="vforangle*(a: Float): Vect"><wbr />vforangle</a></li>
  <li><a class="reference" href="#vtoangle,Vect"
    title="vtoangle*(v: Vect): Float"><wbr />vtoangle</a></li>
  <li><a class="reference" href="#vrotate,Vect,Vect"
    title="vrotate*(v1: Vect; v2: Vect): Vect"><wbr />vrotate</a></li>
  <li><a class="reference" href="#vunrotate,Vect,Vect"
    title="vunrotate*(v1: Vect; v2: Vect): Vect"><wbr />vunrotate</a></li>
  <li><a class="reference" href="#vlengthsq,Vect"
    title="vlengthsq*(v: Vect): Float"><wbr />vlengthsq</a></li>
  <li><a class="reference" href="#vlength,Vect"
    title="vlength*(v: Vect): Float"><wbr />vlength</a></li>
  <li><a class="reference" href="#vlerp,Vect,Vect,Float"
    title="vlerp*(v1: Vect; v2: Vect; t: Float): Vect"><wbr />vlerp</a></li>
  <li><a class="reference" href="#vnormalize,Vect"
    title="vnormalize*(v: Vect): Vect"><wbr />vnormalize</a></li>
  <li><a class="reference" href="#vslerp,Vect,Vect,Float"
    title="vslerp*(v1: Vect; v2: Vect; t: Float): Vect"><wbr />vslerp</a></li>
  <li><a class="reference" href="#vslerpconst,Vect,Vect,Float"
    title="vslerpconst*(v1: Vect; v2: Vect; a: Float): Vect"><wbr />vslerpconst</a></li>
  <li><a class="reference" href="#vclamp,Vect,Float"
    title="vclamp*(v: Vect; len: Float): Vect"><wbr />vclamp</a></li>
  <li><a class="reference" href="#vlerpconst,Vect,Vect,Float"
    title="vlerpconst*(v1: Vect; v2: Vect; d: Float): Vect"><wbr />vlerpconst</a></li>
  <li><a class="reference" href="#vdist,Vect,Vect"
    title="vdist*(v1: Vect; v2: Vect): Float"><wbr />vdist</a></li>
  <li><a class="reference" href="#vdistsq,Vect,Vect"
    title="vdistsq*(v1: Vect; v2: Vect): Float"><wbr />vdistsq</a></li>
  <li><a class="reference" href="#vnear,Vect,Vect,Float"
    title="vnear*(v1: Vect; v2: Vect; dist: Float): bool"><wbr />vnear</a></li>
  <li><a class="reference" href="#newMat2x2,Float,Float,Float,Float"
    title="newMat2x2*(a: Float; b: Float; c: Float; d: Float): Mat2x2"><wbr />new<wbr />Mat2x2</a></li>
  <li><a class="reference" href="#transform,Mat2x2,Vect"
    title="transform*(m: Mat2x2; v: Vect): Vect"><wbr />transform</a></li>
  <li><a class="reference" href="#newBB,Float,Float,Float,Float"
    title="newBB*(l: Float; b: Float; r: Float; t: Float): BB"><wbr />new<wbr />BB</a></li>
  <li><a class="reference" href="#newForExtentsBB,Vect,Float,Float"
    title="newForExtentsBB*(c: Vect; hw: Float; hh: Float): BB"><wbr />new<wbr />For<wbr />Extents<wbr />BB</a></li>
  <li><a class="reference" href="#newForCircleBB,Vect,Float"
    title="newForCircleBB*(p: Vect; r: Float): BB"><wbr />new<wbr />For<wbr />Circle<wbr />BB</a></li>
  <li><a class="reference" href="#intersects,BB,BB"
    title="intersects*(a: BB; b: BB): bool"><wbr />intersects</a></li>
  <li><a class="reference" href="#containsBB,BB,BB"
    title="containsBB*(bb: BB; other: BB): bool"><wbr />contains<wbr />BB</a></li>
  <li><a class="reference" href="#containsVect,BB,Vect"
    title="containsVect*(bb: BB; v: Vect): bool"><wbr />contains<wbr />Vect</a></li>
  <li><a class="reference" href="#merge,BB,BB"
    title="merge*(a: BB; b: BB): BB"><wbr />merge</a></li>
  <li><a class="reference" href="#expand,BB,Vect"
    title="expand*(bb: BB; v: Vect): BB"><wbr />expand</a></li>
  <li><a class="reference" href="#center,BB"
    title="center*(bb: BB): Vect"><wbr />center</a></li>
  <li><a class="reference" href="#area,BB"
    title="area*(bb: BB): Float"><wbr />area</a></li>
  <li><a class="reference" href="#mergedArea,BB,BB"
    title="mergedArea*(a: BB; b: BB): Float"><wbr />merged<wbr />Area</a></li>
  <li><a class="reference" href="#segmentQuery,BB,Vect,Vect"
    title="segmentQuery*(bb: BB; a: Vect; b: Vect): Float"><wbr />segment<wbr />Query</a></li>
  <li><a class="reference" href="#intersectsSegment,BB,Vect,Vect"
    title="intersectsSegment*(bb: BB; a: Vect; b: Vect): bool"><wbr />intersects<wbr />Segment</a></li>
  <li><a class="reference" href="#clampVect,BB,Vect"
    title="clampVect*(bb: BB; v: Vect): Vect"><wbr />clamp<wbr />Vect</a></li>
  <li><a class="reference" href="#wrapVect,BB,Vect"
    title="wrapVect*(bb: BB; v: Vect): Vect"><wbr />wrap<wbr />Vect</a></li>
  <li><a class="reference" href="#offset,BB,Vect"
    title="offset*(bb: BB; v: Vect): BB"><wbr />offset</a></li>
  <li><a class="reference" href="#newTransform,Float,Float,Float,Float,Float,Float"
    title="newTransform*(a: Float; b: Float; c: Float; d: Float; tx: Float; ty: Float): Transform"><wbr />new<wbr />Transform</a></li>
  <li><a class="reference" href="#newTransposeTransform,Float,Float,Float,Float,Float,Float"
    title="newTransposeTransform*(a: Float; c: Float; tx: Float; b: Float; d: Float; ty: Float): Transform"><wbr />new<wbr />Transpose<wbr />Transform</a></li>
  <li><a class="reference" href="#inverse,Transform"
    title="inverse*(t: Transform): Transform"><wbr />inverse</a></li>
  <li><a class="reference" href="#mult,Transform,Transform"
    title="mult*(t1: Transform; t2: Transform): Transform"><wbr />mult</a></li>
  <li><a class="reference" href="#point,Transform,Vect"
    title="point*(t: Transform; p: Vect): Vect"><wbr />point</a></li>
  <li><a class="reference" href="#vect,Transform,Vect"
    title="vect*(t: Transform; v: Vect): Vect"><wbr />vect</a></li>
  <li><a class="reference" href="#transformBB,Transform,BB"
    title="transformBB*(t: Transform; bb: BB): BB"><wbr />transform<wbr />BB</a></li>
  <li><a class="reference" href="#transformTranslate,Vect"
    title="transformTranslate*(translate: Vect): Transform"><wbr />transform<wbr />Translate</a></li>
  <li><a class="reference" href="#transformScale,Float,Float"
    title="transformScale*(scaleX: Float; scaleY: Float): Transform"><wbr />transform<wbr />Scale</a></li>
  <li><a class="reference" href="#transformRotate,Float"
    title="transformRotate*(radians: Float): Transform"><wbr />transform<wbr />Rotate</a></li>
  <li><a class="reference" href="#transformRigid,Vect,Float"
    title="transformRigid*(translate: Vect; radians: Float): Transform"><wbr />transform<wbr />Rigid</a></li>
  <li><a class="reference" href="#transformRigidInverse,Transform"
    title="transformRigidInverse*(t: Transform): Transform"><wbr />transform<wbr />Rigid<wbr />Inverse</a></li>
  <li><a class="reference" href="#transformWrap,Transform,Transform"
    title="transformWrap*(outer: Transform; inner: Transform): Transform"><wbr />transform<wbr />Wrap</a></li>
  <li><a class="reference" href="#transformWrapInverse,Transform,Transform"
    title="transformWrapInverse*(outer: Transform; inner: Transform): Transform"><wbr />transform<wbr />Wrap<wbr />Inverse</a></li>
  <li><a class="reference" href="#transformOrtho,BB"
    title="transformOrtho*(bb: BB): Transform"><wbr />transform<wbr />Ortho</a></li>
  <li><a class="reference" href="#transformBoneScale,Vect,Vect"
    title="transformBoneScale*(v0: Vect; v1: Vect): Transform"><wbr />transform<wbr />Bone<wbr />Scale</a></li>
  <li><a class="reference" href="#transformAxialScale,Vect,Vect,Float"
    title="transformAxialScale*(axis: Vect; pivot: Vect; scale: Float): Transform"><wbr />transform<wbr />Axial<wbr />Scale</a></li>
  <li><a class="reference" href="#allocateSpaceHash,"
    title="allocateSpaceHash*(): SpaceHash"><wbr />allocate<wbr />Space<wbr />Hash</a></li>
  <li><a class="reference" href="#initializeSpaceHash,SpaceHash,Float,cint,SpatialIndexBBFunc,SpatialIndex"
    title="initializeSpaceHash*(hash: SpaceHash; celldim: Float; numcells: cint;
                     bbfunc: SpatialIndexBBFunc; staticIndex: SpatialIndex): SpatialIndex"><wbr />initialize<wbr />Space<wbr />Hash</a></li>
  <li><a class="reference" href="#newSpaceHash,Float,cint,SpatialIndexBBFunc,SpatialIndex"
    title="newSpaceHash*(celldim: Float; cells: cint; bbfunc: SpatialIndexBBFunc;
              staticIndex: SpatialIndex): SpaceHash"><wbr />new<wbr />Space<wbr />Hash</a></li>
  <li><a class="reference" href="#resize,SpaceHash,Float,cint"
    title="resize*(hash: SpaceHash; celldim: Float; numcells: cint)"><wbr />resize</a></li>
  <li><a class="reference" href="#allocateBBTree,"
    title="allocateBBTree*(): BBTree"><wbr />allocate<wbr />BBTree</a></li>
  <li><a class="reference" href="#initializeBBTree,BBTree,SpatialIndexBBFunc,SpatialIndex"
    title="initializeBBTree*(tree: BBTree; bbfunc: SpatialIndexBBFunc;
                  staticIndex: SpatialIndex): SpatialIndex"><wbr />initialize<wbr />BBTree</a></li>
  <li><a class="reference" href="#newBBTree,SpatialIndexBBFunc,SpatialIndex"
    title="newBBTree*(bbfunc: SpatialIndexBBFunc; staticIndex: SpatialIndex): BBTree"><wbr />new<wbr />BBTree</a></li>
  <li><a class="reference" href="#optimize,BBTree"
    title="optimize*(index: BBTree)"><wbr />optimize</a></li>
  <li><a class="reference" href="#=,BBTree,BBTreeVelocityFunc"
    title="`velocityFunc =`*(index: BBTree; `func`: BBTreeVelocityFunc)">`<wbr />velocity<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#allocateSweep1D,"
    title="allocateSweep1D*(): Sweep1D"><wbr />allocate<wbr />Sweep1D</a></li>
  <li><a class="reference" href="#initializeSweep1D,Sweep1D,SpatialIndexBBFunc,SpatialIndex"
    title="initializeSweep1D*(sweep: Sweep1D; bbfunc: SpatialIndexBBFunc;
                   staticIndex: SpatialIndex): SpatialIndex"><wbr />initialize<wbr />Sweep1D</a></li>
  <li><a class="reference" href="#newSweep1D,SpatialIndexBBFunc,SpatialIndex"
    title="newSweep1D*(bbfunc: SpatialIndexBBFunc; staticIndex: SpatialIndex): Sweep1D"><wbr />new<wbr />Sweep1D</a></li>
  <li><a class="reference" href="#destroy,SpatialIndex"
    title="destroy*(index: SpatialIndex)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,Sweep1D"
    title="destroy*(index: Sweep1D)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,SpaceHash"
    title="destroy*(index: SpaceHash)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,BBTree"
    title="destroy*(index: BBTree)"><wbr />destroy</a></li>
  <li><a class="reference" href="#collideStatic,SpatialIndex,SpatialIndex,SpatialIndexQueryFunc,pointer"
    title="collideStatic*(dynamicIndex: SpatialIndex; staticIndex: SpatialIndex;
               `func`: SpatialIndexQueryFunc; data: pointer)"><wbr />collide<wbr />Static</a></li>
  <li><a class="reference" href="#finalize,SpatialIndex"
    title="finalize*(index: SpatialIndex)"><wbr />finalize</a></li>
  <li><a class="reference" href="#count,SpatialIndex"
    title="count*(index: SpatialIndex): cint"><wbr />count</a></li>
  <li><a class="reference" href="#each,SpatialIndex,SpatialIndexIteratorFunc,pointer"
    title="each*(index: SpatialIndex; `func`: SpatialIndexIteratorFunc; data: pointer)"><wbr />each</a></li>
  <li><a class="reference" href="#contains,SpatialIndex,pointer,HashValue"
    title="contains*(index: SpatialIndex; obj: pointer; hashid: HashValue): bool"><wbr />contains</a></li>
  <li><a class="reference" href="#insert,SpatialIndex,pointer,HashValue"
    title="insert*(index: SpatialIndex; obj: pointer; hashid: HashValue)"><wbr />insert</a></li>
  <li><a class="reference" href="#remove,SpatialIndex,pointer,HashValue"
    title="remove*(index: SpatialIndex; obj: pointer; hashid: HashValue)"><wbr />remove</a></li>
  <li><a class="reference" href="#reindex,SpatialIndex"
    title="reindex*(index: SpatialIndex)"><wbr />reindex</a></li>
  <li><a class="reference" href="#reindexObject,SpatialIndex,pointer,HashValue"
    title="reindexObject*(index: SpatialIndex; obj: pointer; hashid: HashValue)"><wbr />reindex<wbr />Object</a></li>
  <li><a class="reference" href="#query,SpatialIndex,pointer,BB,SpatialIndexQueryFunc,pointer"
    title="query*(index: SpatialIndex; obj: pointer; bb: BB; `func`: SpatialIndexQueryFunc;
       data: pointer)"><wbr />query</a></li>
  <li><a class="reference" href="#segmentQuery,SpatialIndex,pointer,Vect,Vect,Float,SpatialIndexSegmentQueryFunc,pointer"
    title="segmentQuery*(index: SpatialIndex; obj: pointer; a: Vect; b: Vect; t_exit: Float;
              `func`: SpatialIndexSegmentQueryFunc; data: pointer)"><wbr />segment<wbr />Query</a></li>
  <li><a class="reference" href="#reindexQuery,SpatialIndex,SpatialIndexQueryFunc,pointer"
    title="reindexQuery*(index: SpatialIndex; `func`: SpatialIndexQueryFunc; data: pointer)"><wbr />reindex<wbr />Query</a></li>
  <li><a class="reference" href="#restitution,Arbiter"
    title="restitution*(arb: Arbiter): Float"><wbr />restitution</a></li>
  <li><a class="reference" href="#=,Arbiter,Float"
    title="`restitution =`*(arb: Arbiter; restitution: Float)">`<wbr />restitution<wbr />=`</a></li>
  <li><a class="reference" href="#friction,Arbiter"
    title="friction*(arb: Arbiter): Float"><wbr />friction</a></li>
  <li><a class="reference" href="#=,Arbiter,Float_2"
    title="`friction =`*(arb: Arbiter; friction: Float)">`<wbr />friction<wbr />=`</a></li>
  <li><a class="reference" href="#surfaceVelocity,Arbiter"
    title="surfaceVelocity*(arb: Arbiter): Vect"><wbr />surface<wbr />Velocity</a></li>
  <li><a class="reference" href="#=,Arbiter,Vect"
    title="`surfaceVelocity =`*(arb: Arbiter; vr: Vect)">`<wbr />surface<wbr />Velocity<wbr />=`</a></li>
  <li><a class="reference" href="#userData,Arbiter"
    title="userData*(arb: Arbiter): DataPointer"><wbr />user<wbr />Data</a></li>
  <li><a class="reference" href="#=,Arbiter,DataPointer"
    title="`userData =`*(arb: Arbiter; userData: DataPointer)">`<wbr />user<wbr />Data<wbr />=`</a></li>
  <li><a class="reference" href="#totalImpulse,Arbiter"
    title="totalImpulse*(arb: Arbiter): Vect"><wbr />total<wbr />Impulse</a></li>
  <li><a class="reference" href="#totalKE,Arbiter"
    title="totalKE*(arb: Arbiter): Float"><wbr />total<wbr />KE</a></li>
  <li><a class="reference" href="#ignore,Arbiter"
    title="ignore*(arb: Arbiter): bool"><wbr />ignore</a></li>
  <li><a class="reference" href="#shapes,Arbiter,ptr.Shape,ptr.Shape"
    title="shapes*(arb: Arbiter; a: ptr Shape; b: ptr Shape)"><wbr />shapes</a></li>
  <li><a class="reference" href="#bodies,Arbiter,ptr.Body,ptr.Body"
    title="bodies*(arb: Arbiter; a: ptr Body; b: ptr Body)"><wbr />bodies</a></li>
  <li><a class="reference" href="#contactPointSet,Arbiter"
    title="contactPointSet*(arb: Arbiter): ContactPointSet"><wbr />contact<wbr />Point<wbr />Set</a></li>
  <li><a class="reference" href="#=,Arbiter,ptr.ContactPointSet"
    title="`contactPointSet =`*(arb: Arbiter; set: ptr ContactPointSet)">`<wbr />contact<wbr />Point<wbr />Set<wbr />=`</a></li>
  <li><a class="reference" href="#isFirstContact,Arbiter"
    title="isFirstContact*(arb: Arbiter): bool"><wbr />is<wbr />First<wbr />Contact</a></li>
  <li><a class="reference" href="#isRemoval,Arbiter"
    title="isRemoval*(arb: Arbiter): bool"><wbr />is<wbr />Removal</a></li>
  <li><a class="reference" href="#count,Arbiter"
    title="count*(arb: Arbiter): cint"><wbr />count</a></li>
  <li><a class="reference" href="#normal,Arbiter"
    title="normal*(arb: Arbiter): Vect"><wbr />normal</a></li>
  <li><a class="reference" href="#pointA,Arbiter,cint"
    title="pointA*(arb: Arbiter; i: cint): Vect"><wbr />point<wbr />A</a></li>
  <li><a class="reference" href="#pointB,Arbiter,cint"
    title="pointB*(arb: Arbiter; i: cint): Vect"><wbr />point<wbr />B</a></li>
  <li><a class="reference" href="#depth,Arbiter,cint"
    title="depth*(arb: Arbiter; i: cint): Float"><wbr />depth</a></li>
  <li><a class="reference" href="#callWildcardBeginA,Arbiter,Space"
    title="callWildcardBeginA*(arb: Arbiter; space: Space): bool"><wbr />call<wbr />Wildcard<wbr />Begin<wbr />A</a></li>
  <li><a class="reference" href="#callWildcardBeginB,Arbiter,Space"
    title="callWildcardBeginB*(arb: Arbiter; space: Space): bool"><wbr />call<wbr />Wildcard<wbr />Begin<wbr />B</a></li>
  <li><a class="reference" href="#callWildcardPreSolveA,Arbiter,Space"
    title="callWildcardPreSolveA*(arb: Arbiter; space: Space): bool"><wbr />call<wbr />Wildcard<wbr />Pre<wbr />Solve<wbr />A</a></li>
  <li><a class="reference" href="#callWildcardPreSolveB,Arbiter,Space"
    title="callWildcardPreSolveB*(arb: Arbiter; space: Space): bool"><wbr />call<wbr />Wildcard<wbr />Pre<wbr />Solve<wbr />B</a></li>
  <li><a class="reference" href="#callWildcardPostSolveA,Arbiter,Space"
    title="callWildcardPostSolveA*(arb: Arbiter; space: Space)"><wbr />call<wbr />Wildcard<wbr />Post<wbr />Solve<wbr />A</a></li>
  <li><a class="reference" href="#callWildcardPostSolveB,Arbiter,Space"
    title="callWildcardPostSolveB*(arb: Arbiter; space: Space)"><wbr />call<wbr />Wildcard<wbr />Post<wbr />Solve<wbr />B</a></li>
  <li><a class="reference" href="#callWildcardSeparateA,Arbiter,Space"
    title="callWildcardSeparateA*(arb: Arbiter; space: Space)"><wbr />call<wbr />Wildcard<wbr />Separate<wbr />A</a></li>
  <li><a class="reference" href="#callWildcardSeparateB,Arbiter,Space"
    title="callWildcardSeparateB*(arb: Arbiter; space: Space)"><wbr />call<wbr />Wildcard<wbr />Separate<wbr />B</a></li>
  <li><a class="reference" href="#allocateBody,"
    title="allocateBody*(): Body"><wbr />allocate<wbr />Body</a></li>
  <li><a class="reference" href="#initializeBody,Body,Float,Float"
    title="initializeBody*(body: Body; mass: Float; moment: Float): Body"><wbr />initialize<wbr />Body</a></li>
  <li><a class="reference" href="#newBody,Float,Float"
    title="newBody*(mass: Float; moment: Float): Body"><wbr />new<wbr />Body</a></li>
  <li><a class="reference" href="#newKinematicBody,"
    title="newKinematicBody*(): Body"><wbr />new<wbr />Kinematic<wbr />Body</a></li>
  <li><a class="reference" href="#newStaticBody,"
    title="newStaticBody*(): Body"><wbr />new<wbr />Static<wbr />Body</a></li>
  <li><a class="reference" href="#finalize,Body"
    title="finalize*(body: Body)"><wbr />finalize</a></li>
  <li><a class="reference" href="#destroy,Body"
    title="destroy*(body: Body)"><wbr />destroy</a></li>
  <li><a class="reference" href="#activate,Body"
    title="activate*(body: Body)"><wbr />activate</a></li>
  <li><a class="reference" href="#activateStatic,Body,Shape"
    title="activateStatic*(body: Body; filter: Shape)"><wbr />activate<wbr />Static</a></li>
  <li><a class="reference" href="#sleep,Body"
    title="sleep*(body: Body)"><wbr />sleep</a></li>
  <li><a class="reference" href="#sleepWithGroup,Body,Body"
    title="sleepWithGroup*(body: Body; group: Body)"><wbr />sleep<wbr />With<wbr />Group</a></li>
  <li><a class="reference" href="#isSleeping,Body"
    title="isSleeping*(body: Body): bool"><wbr />is<wbr />Sleeping</a></li>
  <li><a class="reference" href="#bodyType,Body"
    title="bodyType*(body: Body): BodyType"><wbr />body<wbr />Type</a></li>
  <li><a class="reference" href="#=,Body,BodyType"
    title="`bodyType =`*(body: Body; `type`: BodyType)">`<wbr />body<wbr />Type<wbr />=`</a></li>
  <li><a class="reference" href="#space,Body"
    title="space*(body: Body): Space"><wbr />space</a></li>
  <li><a class="reference" href="#mass,Body"
    title="mass*(body: Body): Float"><wbr />mass</a></li>
  <li><a class="reference" href="#=,Body,Float"
    title="`mass =`*(body: Body; m: Float)">`<wbr />mass<wbr />=`</a></li>
  <li><a class="reference" href="#moment,Body"
    title="moment*(body: Body): Float"><wbr />moment</a></li>
  <li><a class="reference" href="#=,Body,Float_2"
    title="`moment =`*(body: Body; i: Float)">`<wbr />moment<wbr />=`</a></li>
  <li><a class="reference" href="#position,Body"
    title="position*(body: Body): Vect"><wbr />position</a></li>
  <li><a class="reference" href="#=,Body,Vect"
    title="`position =`*(body: Body; pos: Vect)">`<wbr />position<wbr />=`</a></li>
  <li><a class="reference" href="#centerOfGravity,Body"
    title="centerOfGravity*(body: Body): Vect"><wbr />center<wbr />Of<wbr />Gravity</a></li>
  <li><a class="reference" href="#=,Body,Vect_2"
    title="`centerOfGravity =`*(body: Body; cog: Vect)">`<wbr />center<wbr />Of<wbr />Gravity<wbr />=`</a></li>
  <li><a class="reference" href="#velocity,Body"
    title="velocity*(body: Body): Vect"><wbr />velocity</a></li>
  <li><a class="reference" href="#=,Body,Vect_3"
    title="`velocity =`*(body: Body; velocity: Vect)">`<wbr />velocity<wbr />=`</a></li>
  <li><a class="reference" href="#force,Body"
    title="force*(body: Body): Vect"><wbr />force</a></li>
  <li><a class="reference" href="#=,Body,Vect_4"
    title="`force =`*(body: Body; force: Vect)">`<wbr />force<wbr />=`</a></li>
  <li><a class="reference" href="#angle,Body"
    title="angle*(body: Body): Float"><wbr />angle</a></li>
  <li><a class="reference" href="#=,Body,Float_3"
    title="`angle =`*(body: Body; a: Float)">`<wbr />angle<wbr />=`</a></li>
  <li><a class="reference" href="#angularVelocity,Body"
    title="angularVelocity*(body: Body): Float"><wbr />angular<wbr />Velocity</a></li>
  <li><a class="reference" href="#=,Body,Float_4"
    title="`angularVelocity =`*(body: Body; angularVelocity: Float)">`<wbr />angular<wbr />Velocity<wbr />=`</a></li>
  <li><a class="reference" href="#torque,Body"
    title="torque*(body: Body): Float"><wbr />torque</a></li>
  <li><a class="reference" href="#=,Body,Float_5"
    title="`torque =`*(body: Body; torque: Float)">`<wbr />torque<wbr />=`</a></li>
  <li><a class="reference" href="#rotation,Body"
    title="rotation*(body: Body): Vect"><wbr />rotation</a></li>
  <li><a class="reference" href="#userData,Body"
    title="userData*(body: Body): DataPointer"><wbr />user<wbr />Data</a></li>
  <li><a class="reference" href="#=,Body,DataPointer"
    title="`userData =`*(body: Body; userData: DataPointer)">`<wbr />user<wbr />Data<wbr />=`</a></li>
  <li><a class="reference" href="#=,Body,BodyVelocityFunc"
    title="`velocityUpdateFunc =`*(body: Body; velocityFunc: BodyVelocityFunc)">`<wbr />velocity<wbr />Update<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#=,Body,BodyPositionFunc"
    title="`positionUpdateFunc =`*(body: Body; positionFunc: BodyPositionFunc)">`<wbr />position<wbr />Update<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#updateVelocity,Body,Vect,Float,Float"
    title="updateVelocity*(body: Body; gravity: Vect; damping: Float; dt: Float)"><wbr />update<wbr />Velocity</a></li>
  <li><a class="reference" href="#updatePosition,Body,Float"
    title="updatePosition*(body: Body; dt: Float)"><wbr />update<wbr />Position</a></li>
  <li><a class="reference" href="#localToWorld,Body,Vect"
    title="localToWorld*(body: Body; point: Vect): Vect"><wbr />local<wbr />To<wbr />World</a></li>
  <li><a class="reference" href="#worldToLocal,Body,Vect"
    title="worldToLocal*(body: Body; point: Vect): Vect"><wbr />world<wbr />To<wbr />Local</a></li>
  <li><a class="reference" href="#applyForceAtWorldPoint,Body,Vect,Vect"
    title="applyForceAtWorldPoint*(body: Body; force: Vect; point: Vect)"><wbr />apply<wbr />Force<wbr />At<wbr />World<wbr />Point</a></li>
  <li><a class="reference" href="#applyForceAtLocalPoint,Body,Vect,Vect"
    title="applyForceAtLocalPoint*(body: Body; force: Vect; point: Vect)"><wbr />apply<wbr />Force<wbr />At<wbr />Local<wbr />Point</a></li>
  <li><a class="reference" href="#applyImpulseAtWorldPoint,Body,Vect,Vect"
    title="applyImpulseAtWorldPoint*(body: Body; impulse: Vect; point: Vect)"><wbr />apply<wbr />Impulse<wbr />At<wbr />World<wbr />Point</a></li>
  <li><a class="reference" href="#applyImpulseAtLocalPoint,Body,Vect,Vect"
    title="applyImpulseAtLocalPoint*(body: Body; impulse: Vect; point: Vect)"><wbr />apply<wbr />Impulse<wbr />At<wbr />Local<wbr />Point</a></li>
  <li><a class="reference" href="#velocityAtWorldPoint,Body,Vect"
    title="velocityAtWorldPoint*(body: Body; point: Vect): Vect"><wbr />velocity<wbr />At<wbr />World<wbr />Point</a></li>
  <li><a class="reference" href="#velocityAtLocalPoint,Body,Vect"
    title="velocityAtLocalPoint*(body: Body; point: Vect): Vect"><wbr />velocity<wbr />At<wbr />Local<wbr />Point</a></li>
  <li><a class="reference" href="#kineticEnergy,Body"
    title="kineticEnergy*(body: Body): Float"><wbr />kinetic<wbr />Energy</a></li>
  <li><a class="reference" href="#eachShape,Body,BodyShapeIteratorFunc,pointer"
    title="eachShape*(body: Body; `func`: BodyShapeIteratorFunc; data: pointer)"><wbr />each<wbr />Shape</a></li>
  <li><a class="reference" href="#eachConstraint,Body,BodyConstraintIteratorFunc,pointer"
    title="eachConstraint*(body: Body; `func`: BodyConstraintIteratorFunc; data: pointer)"><wbr />each<wbr />Constraint</a></li>
  <li><a class="reference" href="#eachArbiter,Body,BodyArbiterIteratorFunc,pointer"
    title="eachArbiter*(body: Body; `func`: BodyArbiterIteratorFunc; data: pointer)"><wbr />each<wbr />Arbiter</a></li>
  <li><a class="reference" href="#newShapeFilter,Group,Bitmask,Bitmask"
    title="newShapeFilter*(group: Group; categories: Bitmask; mask: Bitmask): ShapeFilter"><wbr />new<wbr />Shape<wbr />Filter</a></li>
  <li><a class="reference" href="#finalize,Shape"
    title="finalize*(shape: Shape)"><wbr />finalize</a></li>
  <li><a class="reference" href="#destroy,Shape"
    title="destroy*(shape: Shape)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,PolyShape"
    title="destroy*(shape: PolyShape)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,SegmentShape"
    title="destroy*(shape: SegmentShape)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,CircleShape"
    title="destroy*(shape: CircleShape)"><wbr />destroy</a></li>
  <li><a class="reference" href="#cacheBB,Shape"
    title="cacheBB*(shape: Shape): BB"><wbr />cache<wbr />BB</a></li>
  <li><a class="reference" href="#update,Shape,Transform"
    title="update*(shape: Shape; transform: Transform): BB"><wbr />update</a></li>
  <li><a class="reference" href="#pointQuery,Shape,Vect,ptr.PointQueryInfo"
    title="pointQuery*(shape: Shape; p: Vect; `out`: ptr PointQueryInfo): Float"><wbr />point<wbr />Query</a></li>
  <li><a class="reference" href="#segmentQuery,Shape,Vect,Vect,Float,ptr.SegmentQueryInfo"
    title="segmentQuery*(shape: Shape; a: Vect; b: Vect; radius: Float; info: ptr SegmentQueryInfo): bool"><wbr />segment<wbr />Query</a></li>
  <li><a class="reference" href="#collide,Shape,Shape"
    title="collide*(a: Shape; b: Shape): ContactPointSet"><wbr />collide</a></li>
  <li><a class="reference" href="#space,Shape"
    title="space*(shape: Shape): Space"><wbr />space</a></li>
  <li><a class="reference" href="#body,Shape"
    title="body*(shape: Shape): Body"><wbr />body</a></li>
  <li><a class="reference" href="#=,Shape,Body"
    title="`body =`*(shape: Shape; body: Body)">`<wbr />body<wbr />=`</a></li>
  <li><a class="reference" href="#mass,Shape"
    title="mass*(shape: Shape): Float"><wbr />mass</a></li>
  <li><a class="reference" href="#=,Shape,Float"
    title="`mass =`*(shape: Shape; mass: Float)">`<wbr />mass<wbr />=`</a></li>
  <li><a class="reference" href="#density,Shape"
    title="density*(shape: Shape): Float"><wbr />density</a></li>
  <li><a class="reference" href="#=,Shape,Float_2"
    title="`density =`*(shape: Shape; density: Float)">`<wbr />density<wbr />=`</a></li>
  <li><a class="reference" href="#moment,Shape"
    title="moment*(shape: Shape): Float"><wbr />moment</a></li>
  <li><a class="reference" href="#area,Shape"
    title="area*(shape: Shape): Float"><wbr />area</a></li>
  <li><a class="reference" href="#centerOfGravity,Shape"
    title="centerOfGravity*(shape: Shape): Vect"><wbr />center<wbr />Of<wbr />Gravity</a></li>
  <li><a class="reference" href="#bB,Shape"
    title="bB*(shape: Shape): BB"><wbr />b<wbr />B</a></li>
  <li><a class="reference" href="#sensor,Shape"
    title="sensor*(shape: Shape): bool"><wbr />sensor</a></li>
  <li><a class="reference" href="#=,Shape,bool"
    title="`sensor =`*(shape: Shape; sensor: bool)">`<wbr />sensor<wbr />=`</a></li>
  <li><a class="reference" href="#elasticity,Shape"
    title="elasticity*(shape: Shape): Float"><wbr />elasticity</a></li>
  <li><a class="reference" href="#=,Shape,Float_3"
    title="`elasticity =`*(shape: Shape; elasticity: Float)">`<wbr />elasticity<wbr />=`</a></li>
  <li><a class="reference" href="#friction,Shape"
    title="friction*(shape: Shape): Float"><wbr />friction</a></li>
  <li><a class="reference" href="#=,Shape,Float_4"
    title="`friction =`*(shape: Shape; friction: Float)">`<wbr />friction<wbr />=`</a></li>
  <li><a class="reference" href="#surfaceVelocity,Shape"
    title="surfaceVelocity*(shape: Shape): Vect"><wbr />surface<wbr />Velocity</a></li>
  <li><a class="reference" href="#=,Shape,Vect"
    title="`surfaceVelocity =`*(shape: Shape; surfaceVelocity: Vect)">`<wbr />surface<wbr />Velocity<wbr />=`</a></li>
  <li><a class="reference" href="#userData,Shape"
    title="userData*(shape: Shape): DataPointer"><wbr />user<wbr />Data</a></li>
  <li><a class="reference" href="#=,Shape,DataPointer"
    title="`userData =`*(shape: Shape; userData: DataPointer)">`<wbr />user<wbr />Data<wbr />=`</a></li>
  <li><a class="reference" href="#collisionType,Shape"
    title="collisionType*(shape: Shape): CollisionType"><wbr />collision<wbr />Type</a></li>
  <li><a class="reference" href="#=,Shape,CollisionType"
    title="`collisionType =`*(shape: Shape; collisionType: CollisionType)">`<wbr />collision<wbr />Type<wbr />=`</a></li>
  <li><a class="reference" href="#filter,Shape"
    title="filter*(shape: Shape): ShapeFilter"><wbr />filter</a></li>
  <li><a class="reference" href="#=,Shape,ShapeFilter"
    title="`filter =`*(shape: Shape; filter: ShapeFilter)">`<wbr />filter<wbr />=`</a></li>
  <li><a class="reference" href="#allocateCircleShape,"
    title="allocateCircleShape*(): CircleShape"><wbr />allocate<wbr />Circle<wbr />Shape</a></li>
  <li><a class="reference" href="#initializeCircleShape,CircleShape,Body,Float,Vect"
    title="initializeCircleShape*(circle: CircleShape; body: Body; radius: Float; offset: Vect): CircleShape"><wbr />initialize<wbr />Circle<wbr />Shape</a></li>
  <li><a class="reference" href="#newCircleShape,Body,Float,Vect"
    title="newCircleShape*(body: Body; radius: Float; offset: Vect): CircleShape"><wbr />new<wbr />Circle<wbr />Shape</a></li>
  <li><a class="reference" href="#offset,CircleShape"
    title="offset*(shape: CircleShape): Vect"><wbr />offset</a></li>
  <li><a class="reference" href="#radius,CircleShape"
    title="radius*(shape: CircleShape): Float"><wbr />radius</a></li>
  <li><a class="reference" href="#allocateSegmentShape,"
    title="allocateSegmentShape*(): SegmentShape"><wbr />allocate<wbr />Segment<wbr />Shape</a></li>
  <li><a class="reference" href="#initializeSegmentShape,SegmentShape,Body,Vect,Vect,Float"
    title="initializeSegmentShape*(seg: SegmentShape; body: Body; a: Vect; b: Vect; radius: Float): SegmentShape"><wbr />initialize<wbr />Segment<wbr />Shape</a></li>
  <li><a class="reference" href="#newSegmentShape,Body,Vect,Vect,Float"
    title="newSegmentShape*(body: Body; a: Vect; b: Vect; radius: Float): SegmentShape"><wbr />new<wbr />Segment<wbr />Shape</a></li>
  <li><a class="reference" href="#=,SegmentShape,Vect,Vect"
    title="`neighbors =`*(shape: SegmentShape; prev: Vect; next: Vect)">`<wbr />neighbors<wbr />=`</a></li>
  <li><a class="reference" href="#a,SegmentShape"
    title="a*(shape: SegmentShape): Vect"><wbr />a</a></li>
  <li><a class="reference" href="#b,SegmentShape"
    title="b*(shape: SegmentShape): Vect"><wbr />b</a></li>
  <li><a class="reference" href="#normal,SegmentShape"
    title="normal*(shape: SegmentShape): Vect"><wbr />normal</a></li>
  <li><a class="reference" href="#radius,SegmentShape"
    title="radius*(shape: SegmentShape): Float"><wbr />radius</a></li>
  <li><a class="reference" href="#allocatePolyShape,"
    title="allocatePolyShape*(): PolyShape"><wbr />allocate<wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#initializePolyShape,PolyShape,Body,cint,ptr.Vect,Transform,Float"
    title="initializePolyShape*(poly: PolyShape; body: Body; count: cint; verts: ptr Vect;
                     transform: Transform; radius: Float): PolyShape"><wbr />initialize<wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#initializePolyShape,PolyShape,Body,cint,ptr.Vect,Float"
    title="initializePolyShape*(poly: PolyShape; body: Body; count: cint; verts: ptr Vect;
                     radius: Float): PolyShape"><wbr />initialize<wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#newPolyShape,Body,cint,ptr.Vect,Transform,Float"
    title="newPolyShape*(body: Body; count: cint; verts: ptr Vect; transform: Transform;
              radius: Float): PolyShape"><wbr />new<wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#newPolyShape,Body,cint,ptr.Vect,Float"
    title="newPolyShape*(body: Body; count: cint; verts: ptr Vect; radius: Float): PolyShape"><wbr />new<wbr />Poly<wbr />Shape</a></li>
  <li><a class="reference" href="#initializeBoxShape,PolyShape,Body,Float,Float,Float"
    title="initializeBoxShape*(poly: PolyShape; body: Body; width: Float; height: Float;
                    radius: Float): PolyShape"><wbr />initialize<wbr />Box<wbr />Shape</a></li>
  <li><a class="reference" href="#initializeBoxShape,PolyShape,Body,BB,Float"
    title="initializeBoxShape*(poly: PolyShape; body: Body; box: BB; radius: Float): PolyShape"><wbr />initialize<wbr />Box<wbr />Shape</a></li>
  <li><a class="reference" href="#newBoxShape,Body,Float,Float,Float"
    title="newBoxShape*(body: Body; width: Float; height: Float; radius: Float): PolyShape"><wbr />new<wbr />Box<wbr />Shape</a></li>
  <li><a class="reference" href="#newBoxShape,Body,BB,Float"
    title="newBoxShape*(body: Body; box: BB; radius: Float): PolyShape"><wbr />new<wbr />Box<wbr />Shape</a></li>
  <li><a class="reference" href="#count,PolyShape"
    title="count*(shape: PolyShape): cint"><wbr />count</a></li>
  <li><a class="reference" href="#vert,PolyShape,cint"
    title="vert*(shape: PolyShape; index: cint): Vect"><wbr />vert</a></li>
  <li><a class="reference" href="#radius,PolyShape"
    title="radius*(shape: PolyShape): Float"><wbr />radius</a></li>
  <li><a class="reference" href="#finalize,Constraint"
    title="finalize*(constraint: Constraint)"><wbr />finalize</a></li>
  <li><a class="reference" href="#destroy,Constraint"
    title="destroy*(constraint: Constraint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,PinJoint"
    title="destroy*(constraint: PinJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,DampedSpring"
    title="destroy*(constraint: DampedSpring)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,RotaryLimitJoint"
    title="destroy*(constraint: RotaryLimitJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,SlideJoint"
    title="destroy*(constraint: SlideJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,GearJoint"
    title="destroy*(constraint: GearJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,DampedRotarySpring"
    title="destroy*(constraint: DampedRotarySpring)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,GrooveJoint"
    title="destroy*(constraint: GrooveJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,RatchetJoint"
    title="destroy*(constraint: RatchetJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,SimpleMotor"
    title="destroy*(constraint: SimpleMotor)"><wbr />destroy</a></li>
  <li><a class="reference" href="#destroy,PivotJoint"
    title="destroy*(constraint: PivotJoint)"><wbr />destroy</a></li>
  <li><a class="reference" href="#space,Constraint"
    title="space*(constraint: Constraint): Space"><wbr />space</a></li>
  <li><a class="reference" href="#bodyA,Constraint"
    title="bodyA*(constraint: Constraint): Body"><wbr />body<wbr />A</a></li>
  <li><a class="reference" href="#bodyB,Constraint"
    title="bodyB*(constraint: Constraint): Body"><wbr />body<wbr />B</a></li>
  <li><a class="reference" href="#maxForce,Constraint"
    title="maxForce*(constraint: Constraint): Float"><wbr />max<wbr />Force</a></li>
  <li><a class="reference" href="#=,Constraint,Float"
    title="`maxForce =`*(constraint: Constraint; maxForce: Float)">`<wbr />max<wbr />Force<wbr />=`</a></li>
  <li><a class="reference" href="#errorBias,Constraint"
    title="errorBias*(constraint: Constraint): Float"><wbr />error<wbr />Bias</a></li>
  <li><a class="reference" href="#=,Constraint,Float_2"
    title="`errorBias =`*(constraint: Constraint; errorBias: Float)">`<wbr />error<wbr />Bias<wbr />=`</a></li>
  <li><a class="reference" href="#maxBias,Constraint"
    title="maxBias*(constraint: Constraint): Float"><wbr />max<wbr />Bias</a></li>
  <li><a class="reference" href="#=,Constraint,Float_3"
    title="`maxBias =`*(constraint: Constraint; maxBias: Float)">`<wbr />max<wbr />Bias<wbr />=`</a></li>
  <li><a class="reference" href="#collideBodies,Constraint"
    title="collideBodies*(constraint: Constraint): bool"><wbr />collide<wbr />Bodies</a></li>
  <li><a class="reference" href="#=,Constraint,bool"
    title="`collideBodies =`*(constraint: Constraint; collideBodies: bool)">`<wbr />collide<wbr />Bodies<wbr />=`</a></li>
  <li><a class="reference" href="#preSolveFunc,Constraint"
    title="preSolveFunc*(constraint: Constraint): ConstraintPreSolveFunc"><wbr />pre<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#=,Constraint,ConstraintPreSolveFunc"
    title="`preSolveFunc =`*(constraint: Constraint; preSolveFunc: ConstraintPreSolveFunc)">`<wbr />pre<wbr />Solve<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#postSolveFunc,Constraint"
    title="postSolveFunc*(constraint: Constraint): ConstraintPostSolveFunc"><wbr />post<wbr />Solve<wbr />Func</a></li>
  <li><a class="reference" href="#=,Constraint,ConstraintPostSolveFunc"
    title="`postSolveFunc =`*(constraint: Constraint; postSolveFunc: ConstraintPostSolveFunc)">`<wbr />post<wbr />Solve<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#userData,Constraint"
    title="userData*(constraint: Constraint): DataPointer"><wbr />user<wbr />Data</a></li>
  <li><a class="reference" href="#=,Constraint,DataPointer"
    title="`userData =`*(constraint: Constraint; userData: DataPointer)">`<wbr />user<wbr />Data<wbr />=`</a></li>
  <li><a class="reference" href="#impulse,Constraint"
    title="impulse*(constraint: Constraint): Float"><wbr />impulse</a></li>
  <li><a class="reference" href="#isPinJoint,Constraint"
    title="isPinJoint*(constraint: Constraint): bool"><wbr />is<wbr />Pin<wbr />Joint</a></li>
  <li><a class="reference" href="#allocatePinJoint,"
    title="allocatePinJoint*(): PinJoint"><wbr />allocate<wbr />Pin<wbr />Joint</a></li>
  <li><a class="reference" href="#initializePinJoint,PinJoint,Body,Body,Vect,Vect"
    title="initializePinJoint*(joint: PinJoint; a: Body; b: Body; anchorA: Vect; anchorB: Vect): PinJoint"><wbr />initialize<wbr />Pin<wbr />Joint</a></li>
  <li><a class="reference" href="#newPinJoint,Body,Body,Vect,Vect"
    title="newPinJoint*(a: Body; b: Body; anchorA: Vect; anchorB: Vect): PinJoint"><wbr />new<wbr />Pin<wbr />Joint</a></li>
  <li><a class="reference" href="#anchorA,PinJoint"
    title="anchorA*(constraint: PinJoint): Vect"><wbr />anchor<wbr />A</a></li>
  <li><a class="reference" href="#=,PinJoint,Vect"
    title="`anchorA =`*(constraint: PinJoint; anchorA: Vect)">`<wbr />anchor<wbr />A<wbr />=`</a></li>
  <li><a class="reference" href="#anchorB,PinJoint"
    title="anchorB*(constraint: PinJoint): Vect"><wbr />anchor<wbr />B</a></li>
  <li><a class="reference" href="#=,PinJoint,Vect_2"
    title="`anchorB =`*(constraint: PinJoint; anchorB: Vect)">`<wbr />anchor<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#dist,PinJoint"
    title="dist*(constraint: PinJoint): Float"><wbr />dist</a></li>
  <li><a class="reference" href="#=,PinJoint,Float"
    title="`dist =`*(constraint: PinJoint; dist: Float)">`<wbr />dist<wbr />=`</a></li>
  <li><a class="reference" href="#isSlideJoint,Constraint"
    title="isSlideJoint*(constraint: Constraint): bool"><wbr />is<wbr />Slide<wbr />Joint</a></li>
  <li><a class="reference" href="#allocateSlideJoint,"
    title="allocateSlideJoint*(): SlideJoint"><wbr />allocate<wbr />Slide<wbr />Joint</a></li>
  <li><a class="reference" href="#initializeSlideJoint,SlideJoint,Body,Body,Vect,Vect,Float,Float"
    title="initializeSlideJoint*(joint: SlideJoint; a: Body; b: Body; anchorA: Vect; anchorB: Vect;
                      min: Float; max: Float): SlideJoint"><wbr />initialize<wbr />Slide<wbr />Joint</a></li>
  <li><a class="reference" href="#newSlideJoint,Body,Body,Vect,Vect,Float,Float"
    title="newSlideJoint*(a: Body; b: Body; anchorA: Vect; anchorB: Vect; min: Float; max: Float): SlideJoint"><wbr />new<wbr />Slide<wbr />Joint</a></li>
  <li><a class="reference" href="#anchorA,SlideJoint"
    title="anchorA*(constraint: SlideJoint): Vect"><wbr />anchor<wbr />A</a></li>
  <li><a class="reference" href="#=,SlideJoint,Vect"
    title="`anchorA =`*(constraint: SlideJoint; anchorA: Vect)">`<wbr />anchor<wbr />A<wbr />=`</a></li>
  <li><a class="reference" href="#anchorB,SlideJoint"
    title="anchorB*(constraint: SlideJoint): Vect"><wbr />anchor<wbr />B</a></li>
  <li><a class="reference" href="#=,SlideJoint,Vect_2"
    title="`anchorB =`*(constraint: SlideJoint; anchorB: Vect)">`<wbr />anchor<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#min,SlideJoint"
    title="min*(constraint: SlideJoint): Float"><wbr />min</a></li>
  <li><a class="reference" href="#=,SlideJoint,Float"
    title="`min =`*(constraint: SlideJoint; min: Float)">`<wbr />min<wbr />=`</a></li>
  <li><a class="reference" href="#max,SlideJoint"
    title="max*(constraint: SlideJoint): Float"><wbr />max</a></li>
  <li><a class="reference" href="#=,SlideJoint,Float_2"
    title="`max =`*(constraint: SlideJoint; max: Float)">`<wbr />max<wbr />=`</a></li>
  <li><a class="reference" href="#isPivotJoint,Constraint"
    title="isPivotJoint*(constraint: Constraint): bool"><wbr />is<wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#allocatePivotJoint,"
    title="allocatePivotJoint*(): PivotJoint"><wbr />allocate<wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#initializePivotJoint,PivotJoint,Body,Body,Vect,Vect"
    title="initializePivotJoint*(joint: PivotJoint; a: Body; b: Body; anchorA: Vect; anchorB: Vect): PivotJoint"><wbr />initialize<wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#newPivotJoint,Body,Body,Vect"
    title="newPivotJoint*(a: Body; b: Body; pivot: Vect): PivotJoint"><wbr />new<wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#newPivotJoint,Body,Body,Vect,Vect"
    title="newPivotJoint*(a: Body; b: Body; anchorA: Vect; anchorB: Vect): PivotJoint"><wbr />new<wbr />Pivot<wbr />Joint</a></li>
  <li><a class="reference" href="#anchorA,PivotJoint"
    title="anchorA*(constraint: PivotJoint): Vect"><wbr />anchor<wbr />A</a></li>
  <li><a class="reference" href="#=,PivotJoint,Vect"
    title="`anchorA =`*(constraint: PivotJoint; anchorA: Vect)">`<wbr />anchor<wbr />A<wbr />=`</a></li>
  <li><a class="reference" href="#anchorB,PivotJoint"
    title="anchorB*(constraint: PivotJoint): Vect"><wbr />anchor<wbr />B</a></li>
  <li><a class="reference" href="#=,PivotJoint,Vect_2"
    title="`anchorB =`*(constraint: PivotJoint; anchorB: Vect)">`<wbr />anchor<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#isGrooveJoint,Constraint"
    title="isGrooveJoint*(constraint: Constraint): bool"><wbr />is<wbr />Groove<wbr />Joint</a></li>
  <li><a class="reference" href="#allocateGrooveJoint,"
    title="allocateGrooveJoint*(): GrooveJoint"><wbr />allocate<wbr />Groove<wbr />Joint</a></li>
  <li><a class="reference" href="#initializeGrooveJoint,GrooveJoint,Body,Body,Vect,Vect,Vect"
    title="initializeGrooveJoint*(joint: GrooveJoint; a: Body; b: Body; groove_a: Vect;
                       groove_b: Vect; anchorB: Vect): GrooveJoint"><wbr />initialize<wbr />Groove<wbr />Joint</a></li>
  <li><a class="reference" href="#newGrooveJoint,Body,Body,Vect,Vect,Vect"
    title="newGrooveJoint*(a: Body; b: Body; groove_a: Vect; groove_b: Vect; anchorB: Vect): GrooveJoint"><wbr />new<wbr />Groove<wbr />Joint</a></li>
  <li><a class="reference" href="#grooveA,GrooveJoint"
    title="grooveA*(constraint: GrooveJoint): Vect"><wbr />groove<wbr />A</a></li>
  <li><a class="reference" href="#=,GrooveJoint,Vect"
    title="`grooveA =`*(constraint: GrooveJoint; grooveA: Vect)">`<wbr />groove<wbr />A<wbr />=`</a></li>
  <li><a class="reference" href="#grooveB,GrooveJoint"
    title="grooveB*(constraint: GrooveJoint): Vect"><wbr />groove<wbr />B</a></li>
  <li><a class="reference" href="#=,GrooveJoint,Vect_2"
    title="`grooveB =`*(constraint: GrooveJoint; grooveB: Vect)">`<wbr />groove<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#anchorB,GrooveJoint"
    title="anchorB*(constraint: GrooveJoint): Vect"><wbr />anchor<wbr />B</a></li>
  <li><a class="reference" href="#=,GrooveJoint,Vect_3"
    title="`anchorB =`*(constraint: GrooveJoint; anchorB: Vect)">`<wbr />anchor<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#isDampedSpring,Constraint"
    title="isDampedSpring*(constraint: Constraint): bool"><wbr />is<wbr />Damped<wbr />Spring</a></li>
  <li><a class="reference" href="#allocateDampedSpring,"
    title="allocateDampedSpring*(): DampedSpring"><wbr />allocate<wbr />Damped<wbr />Spring</a></li>
  <li><a class="reference" href="#initializeDampedSpring,DampedSpring,Body,Body,Vect,Vect,Float,Float,Float"
    title="initializeDampedSpring*(joint: DampedSpring; a: Body; b: Body; anchorA: Vect;
                        anchorB: Vect; restLength: Float; stiffness: Float;
                        damping: Float): DampedSpring"><wbr />initialize<wbr />Damped<wbr />Spring</a></li>
  <li><a class="reference" href="#newDampedSpring,Body,Body,Vect,Vect,Float,Float,Float"
    title="newDampedSpring*(a: Body; b: Body; anchorA: Vect; anchorB: Vect; restLength: Float;
                 stiffness: Float; damping: Float): DampedSpring"><wbr />new<wbr />Damped<wbr />Spring</a></li>
  <li><a class="reference" href="#anchorA,DampedSpring"
    title="anchorA*(constraint: DampedSpring): Vect"><wbr />anchor<wbr />A</a></li>
  <li><a class="reference" href="#=,DampedSpring,Vect"
    title="`anchorA =`*(constraint: DampedSpring; anchorA: Vect)">`<wbr />anchor<wbr />A<wbr />=`</a></li>
  <li><a class="reference" href="#anchorB,DampedSpring"
    title="anchorB*(constraint: DampedSpring): Vect"><wbr />anchor<wbr />B</a></li>
  <li><a class="reference" href="#=,DampedSpring,Vect_2"
    title="`anchorB =`*(constraint: DampedSpring; anchorB: Vect)">`<wbr />anchor<wbr />B<wbr />=`</a></li>
  <li><a class="reference" href="#restLength,DampedSpring"
    title="restLength*(constraint: DampedSpring): Float"><wbr />rest<wbr />Length</a></li>
  <li><a class="reference" href="#=,DampedSpring,Float"
    title="`restLength =`*(constraint: DampedSpring; restLength: Float)">`<wbr />rest<wbr />Length<wbr />=`</a></li>
  <li><a class="reference" href="#stiffness,DampedSpring"
    title="stiffness*(constraint: DampedSpring): Float"><wbr />stiffness</a></li>
  <li><a class="reference" href="#=,DampedSpring,Float_2"
    title="`stiffness =`*(constraint: DampedSpring; stiffness: Float)">`<wbr />stiffness<wbr />=`</a></li>
  <li><a class="reference" href="#damping,DampedSpring"
    title="damping*(constraint: DampedSpring): Float"><wbr />damping</a></li>
  <li><a class="reference" href="#=,DampedSpring,Float_3"
    title="`damping =`*(constraint: DampedSpring; damping: Float)">`<wbr />damping<wbr />=`</a></li>
  <li><a class="reference" href="#springForceFunc,DampedSpring"
    title="springForceFunc*(constraint: DampedSpring): DampedSpringForceFunc"><wbr />spring<wbr />Force<wbr />Func</a></li>
  <li><a class="reference" href="#=,DampedSpring,DampedSpringForceFunc"
    title="`springForceFunc =`*(constraint: DampedSpring;
                    springForceFunc: DampedSpringForceFunc)">`<wbr />spring<wbr />Force<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#isDampedRotarySpring,Constraint"
    title="isDampedRotarySpring*(constraint: Constraint): bool"><wbr />is<wbr />Damped<wbr />Rotary<wbr />Spring</a></li>
  <li><a class="reference" href="#allocateDampedRotarySpring,"
    title="allocateDampedRotarySpring*(): DampedRotarySpring"><wbr />allocate<wbr />Damped<wbr />Rotary<wbr />Spring</a></li>
  <li><a class="reference" href="#initializeDampedRotarySpring,DampedRotarySpring,Body,Body,Float,Float,Float"
    title="initializeDampedRotarySpring*(joint: DampedRotarySpring; a: Body; b: Body;
                              restAngle: Float; stiffness: Float; damping: Float): DampedRotarySpring"><wbr />initialize<wbr />Damped<wbr />Rotary<wbr />Spring</a></li>
  <li><a class="reference" href="#newDampedRotarySpring,Body,Body,Float,Float,Float"
    title="newDampedRotarySpring*(a: Body; b: Body; restAngle: Float; stiffness: Float;
                       damping: Float): DampedRotarySpring"><wbr />new<wbr />Damped<wbr />Rotary<wbr />Spring</a></li>
  <li><a class="reference" href="#restAngle,DampedRotarySpring"
    title="restAngle*(constraint: DampedRotarySpring): Float"><wbr />rest<wbr />Angle</a></li>
  <li><a class="reference" href="#=,DampedRotarySpring,Float"
    title="`restAngle =`*(constraint: DampedRotarySpring; restAngle: Float)">`<wbr />rest<wbr />Angle<wbr />=`</a></li>
  <li><a class="reference" href="#stiffness,DampedRotarySpring"
    title="stiffness*(constraint: DampedRotarySpring): Float"><wbr />stiffness</a></li>
  <li><a class="reference" href="#=,DampedRotarySpring,Float_2"
    title="`stiffness =`*(constraint: DampedRotarySpring; stiffness: Float)">`<wbr />stiffness<wbr />=`</a></li>
  <li><a class="reference" href="#damping,DampedRotarySpring"
    title="damping*(constraint: DampedRotarySpring): Float"><wbr />damping</a></li>
  <li><a class="reference" href="#=,DampedRotarySpring,Float_3"
    title="`damping =`*(constraint: DampedRotarySpring; damping: Float)">`<wbr />damping<wbr />=`</a></li>
  <li><a class="reference" href="#springTorqueFunc,DampedRotarySpring"
    title="springTorqueFunc*(constraint: DampedRotarySpring): DampedRotarySpringTorqueFunc"><wbr />spring<wbr />Torque<wbr />Func</a></li>
  <li><a class="reference" href="#=,DampedRotarySpring,DampedRotarySpringTorqueFunc"
    title="`springTorqueFunc =`*(constraint: DampedRotarySpring;
                     springTorqueFunc: DampedRotarySpringTorqueFunc)">`<wbr />spring<wbr />Torque<wbr />Func<wbr />=`</a></li>
  <li><a class="reference" href="#isRotaryLimitJoint,Constraint"
    title="isRotaryLimitJoint*(constraint: Constraint): bool"><wbr />is<wbr />Rotary<wbr />Limit<wbr />Joint</a></li>
  <li><a class="reference" href="#allocateRotaryLimitJoint,"
    title="allocateRotaryLimitJoint*(): RotaryLimitJoint"><wbr />allocate<wbr />Rotary<wbr />Limit<wbr />Joint</a></li>
  <li><a class="reference" href="#initializeRotaryLimitJoint,RotaryLimitJoint,Body,Body,Float,Float"
    title="initializeRotaryLimitJoint*(joint: RotaryLimitJoint; a: Body; b: Body; min: Float;
                            max: Float): RotaryLimitJoint"><wbr />initialize<wbr />Rotary<wbr />Limit<wbr />Joint</a></li>
  <li><a class="reference" href="#newRotaryLimitJoint,Body,Body,Float,Float"
    title="newRotaryLimitJoint*(a: Body; b: Body; min: Float; max: Float): RotaryLimitJoint"><wbr />new<wbr />Rotary<wbr />Limit<wbr />Joint</a></li>
  <li><a class="reference" href="#min,RotaryLimitJoint"
    title="min*(constraint: RotaryLimitJoint): Float"><wbr />min</a></li>
  <li><a class="reference" href="#=,RotaryLimitJoint,Float"
    title="`min =`*(constraint: RotaryLimitJoint; min: Float)">`<wbr />min<wbr />=`</a></li>
  <li><a class="reference" href="#max,RotaryLimitJoint"
    title="max*(constraint: RotaryLimitJoint): Float"><wbr />max</a></li>
  <li><a class="reference" href="#=,RotaryLimitJoint,Float_2"
    title="`max =`*(constraint: RotaryLimitJoint; max: Float)">`<wbr />max<wbr />=`</a></li>
  <li><a class="reference" href="#isRatchetJoint,Constraint"
    title="isRatchetJoint*(constraint: Constraint): bool"><wbr />is<wbr />Ratchet<wbr />Joint</a></li>
  <li><a class="reference" href="#allocateRatchetJoint,"
    title="allocateRatchetJoint*(): RatchetJoint"><wbr />allocate<wbr />Ratchet<wbr />Joint</a></li>
  <li><a class="reference" href="#initializeRatchetJoint,RatchetJoint,Body,Body,Float,Float"
    title="initializeRatchetJoint*(joint: RatchetJoint; a: Body; b: Body; phase: Float;
                        ratchet: Float): RatchetJoint"><wbr />initialize<wbr />Ratchet<wbr />Joint</a></li>
  <li><a class="reference" href="#newRatchetJoint,Body,Body,Float,Float"
    title="newRatchetJoint*(a: Body; b: Body; phase: Float; ratchet: Float): RatchetJoint"><wbr />new<wbr />Ratchet<wbr />Joint</a></li>
  <li><a class="reference" href="#angle,RatchetJoint"
    title="angle*(constraint: RatchetJoint): Float"><wbr />angle</a></li>
  <li><a class="reference" href="#=,RatchetJoint,Float"
    title="`angle =`*(constraint: RatchetJoint; angle: Float)">`<wbr />angle<wbr />=`</a></li>
  <li><a class="reference" href="#phase,RatchetJoint"
    title="phase*(constraint: RatchetJoint): Float"><wbr />phase</a></li>
  <li><a class="reference" href="#=,RatchetJoint,Float_2"
    title="`phase =`*(constraint: RatchetJoint; phase: Float)">`<wbr />phase<wbr />=`</a></li>
  <li><a class="reference" href="#ratchet,RatchetJoint"
    title="ratchet*(constraint: RatchetJoint): Float"><wbr />ratchet</a></li>
  <li><a class="reference" href="#=,RatchetJoint,Float_3"
    title="`ratchet =`*(constraint: RatchetJoint; ratchet: Float)">`<wbr />ratchet<wbr />=`</a></li>
  <li><a class="reference" href="#isGearJoint,Constraint"
    title="isGearJoint*(constraint: Constraint): bool"><wbr />is<wbr />Gear<wbr />Joint</a></li>
  <li><a class="reference" href="#allocateGearJoint,"
    title="allocateGearJoint*(): GearJoint"><wbr />allocate<wbr />Gear<wbr />Joint</a></li>
  <li><a class="reference" href="#initializeGearJoint,GearJoint,Body,Body,Float,Float"
    title="initializeGearJoint*(joint: GearJoint; a: Body; b: Body; phase: Float; ratio: Float): GearJoint"><wbr />initialize<wbr />Gear<wbr />Joint</a></li>
  <li><a class="reference" href="#newGearJoint,Body,Body,Float,Float"
    title="newGearJoint*(a: Body; b: Body; phase: Float; ratio: Float): GearJoint"><wbr />new<wbr />Gear<wbr />Joint</a></li>
  <li><a class="reference" href="#phase,GearJoint"
    title="phase*(constraint: GearJoint): Float"><wbr />phase</a></li>
  <li><a class="reference" href="#=,GearJoint,Float"
    title="`phase =`*(constraint: GearJoint; phase: Float)">`<wbr />phase<wbr />=`</a></li>
  <li><a class="reference" href="#ratio,GearJoint"
    title="ratio*(constraint: GearJoint): Float"><wbr />ratio</a></li>
  <li><a class="reference" href="#=,GearJoint,Float_2"
    title="`ratio =`*(constraint: GearJoint; ratio: Float)">`<wbr />ratio<wbr />=`</a></li>
  <li><a class="reference" href="#isSimpleMotor,Constraint"
    title="isSimpleMotor*(constraint: Constraint): bool"><wbr />is<wbr />Simple<wbr />Motor</a></li>
  <li><a class="reference" href="#allocateSimpleMotor,"
    title="allocateSimpleMotor*(): SimpleMotor"><wbr />allocate<wbr />Simple<wbr />Motor</a></li>
  <li><a class="reference" href="#initializeSimpleMotor,SimpleMotor,Body,Body,Float"
    title="initializeSimpleMotor*(joint: SimpleMotor; a: Body; b: Body; rate: Float): SimpleMotor"><wbr />initialize<wbr />Simple<wbr />Motor</a></li>
  <li><a class="reference" href="#newSimpleMotor,Body,Body,Float"
    title="newSimpleMotor*(a: Body; b: Body; rate: Float): SimpleMotor"><wbr />new<wbr />Simple<wbr />Motor</a></li>
  <li><a class="reference" href="#rate,SimpleMotor"
    title="rate*(constraint: SimpleMotor): Float"><wbr />rate</a></li>
  <li><a class="reference" href="#=,SimpleMotor,Float"
    title="`rate =`*(constraint: SimpleMotor; rate: Float)">`<wbr />rate<wbr />=`</a></li>
  <li><a class="reference" href="#allocateSpace,"
    title="allocateSpace*(): Space"><wbr />allocate<wbr />Space</a></li>
  <li><a class="reference" href="#initializeSpace,Space"
    title="initializeSpace*(space: Space): Space"><wbr />initialize<wbr />Space</a></li>
  <li><a class="reference" href="#newSpace,"
    title="newSpace*(): Space"><wbr />new<wbr />Space</a></li>
  <li><a class="reference" href="#finalize,Space"
    title="finalize*(space: Space)"><wbr />finalize</a></li>
  <li><a class="reference" href="#destroy,Space"
    title="destroy*(space: Space)"><wbr />destroy</a></li>
  <li><a class="reference" href="#iterations,Space"
    title="iterations*(space: Space): cint"><wbr />iterations</a></li>
  <li><a class="reference" href="#=,Space,cint"
    title="`iterations =`*(space: Space; iterations: cint)">`<wbr />iterations<wbr />=`</a></li>
  <li><a class="reference" href="#gravity,Space"
    title="gravity*(space: Space): Vect"><wbr />gravity</a></li>
  <li><a class="reference" href="#=,Space,Vect"
    title="`gravity =`*(space: Space; gravity: Vect)">`<wbr />gravity<wbr />=`</a></li>
  <li><a class="reference" href="#damping,Space"
    title="damping*(space: Space): Float"><wbr />damping</a></li>
  <li><a class="reference" href="#=,Space,Float"
    title="`damping =`*(space: Space; damping: Float)">`<wbr />damping<wbr />=`</a></li>
  <li><a class="reference" href="#idleSpeedThreshold,Space"
    title="idleSpeedThreshold*(space: Space): Float"><wbr />idle<wbr />Speed<wbr />Threshold</a></li>
  <li><a class="reference" href="#=,Space,Float_2"
    title="`idleSpeedThreshold =`*(space: Space; idleSpeedThreshold: Float)">`<wbr />idle<wbr />Speed<wbr />Threshold<wbr />=`</a></li>
  <li><a class="reference" href="#sleepTimeThreshold,Space"
    title="sleepTimeThreshold*(space: Space): Float"><wbr />sleep<wbr />Time<wbr />Threshold</a></li>
  <li><a class="reference" href="#=,Space,Float_3"
    title="`sleepTimeThreshold =`*(space: Space; sleepTimeThreshold: Float)">`<wbr />sleep<wbr />Time<wbr />Threshold<wbr />=`</a></li>
  <li><a class="reference" href="#collisionSlop,Space"
    title="collisionSlop*(space: Space): Float"><wbr />collision<wbr />Slop</a></li>
  <li><a class="reference" href="#=,Space,Float_4"
    title="`collisionSlop =`*(space: Space; collisionSlop: Float)">`<wbr />collision<wbr />Slop<wbr />=`</a></li>
  <li><a class="reference" href="#collisionBias,Space"
    title="collisionBias*(space: Space): Float"><wbr />collision<wbr />Bias</a></li>
  <li><a class="reference" href="#=,Space,Float_5"
    title="`collisionBias =`*(space: Space; collisionBias: Float)">`<wbr />collision<wbr />Bias<wbr />=`</a></li>
  <li><a class="reference" href="#collisionPersistence,Space"
    title="collisionPersistence*(space: Space): Timestamp"><wbr />collision<wbr />Persistence</a></li>
  <li><a class="reference" href="#=,Space,Timestamp"
    title="`collisionPersistence =`*(space: Space; collisionPersistence: Timestamp)">`<wbr />collision<wbr />Persistence<wbr />=`</a></li>
  <li><a class="reference" href="#userData,Space"
    title="userData*(space: Space): DataPointer"><wbr />user<wbr />Data</a></li>
  <li><a class="reference" href="#=,Space,DataPointer"
    title="`userData =`*(space: Space; userData: DataPointer)">`<wbr />user<wbr />Data<wbr />=`</a></li>
  <li><a class="reference" href="#staticBody,Space"
    title="staticBody*(space: Space): Body"><wbr />static<wbr />Body</a></li>
  <li><a class="reference" href="#currentTimeStep,Space"
    title="currentTimeStep*(space: Space): Float"><wbr />current<wbr />Time<wbr />Step</a></li>
  <li><a class="reference" href="#isLocked,Space"
    title="isLocked*(space: Space): bool"><wbr />is<wbr />Locked</a></li>
  <li><a class="reference" href="#addDefaultCollisionHandler,Space"
    title="addDefaultCollisionHandler*(space: Space): ptr CollisionHandler"><wbr />add<wbr />Default<wbr />Collision<wbr />Handler</a></li>
  <li><a class="reference" href="#addCollisionHandler,Space,CollisionType,CollisionType"
    title="addCollisionHandler*(space: Space; a: CollisionType; b: CollisionType): ptr CollisionHandler"><wbr />add<wbr />Collision<wbr />Handler</a></li>
  <li><a class="reference" href="#addWildcardHandler,Space,CollisionType"
    title="addWildcardHandler*(space: Space; `type`: CollisionType): ptr CollisionHandler"><wbr />add<wbr />Wildcard<wbr />Handler</a></li>
  <li><a class="reference" href="#addShape,Space,Shape"
    title="addShape*(space: Space; shape: Shape): Shape"><wbr />add<wbr />Shape</a></li>
  <li><a class="reference" href="#addBody,Space,Body"
    title="addBody*(space: Space; body: Body): Body"><wbr />add<wbr />Body</a></li>
  <li><a class="reference" href="#addConstraint,Space,Constraint"
    title="addConstraint*(space: Space; constraint: Constraint): Constraint"><wbr />add<wbr />Constraint</a></li>
  <li><a class="reference" href="#removeShape,Space,Shape"
    title="removeShape*(space: Space; shape: Shape)"><wbr />remove<wbr />Shape</a></li>
  <li><a class="reference" href="#removeBody,Space,Body"
    title="removeBody*(space: Space; body: Body)"><wbr />remove<wbr />Body</a></li>
  <li><a class="reference" href="#removeConstraint,Space,Constraint"
    title="removeConstraint*(space: Space; constraint: Constraint)"><wbr />remove<wbr />Constraint</a></li>
  <li><a class="reference" href="#containsShape,Space,Shape"
    title="containsShape*(space: Space; shape: Shape): bool"><wbr />contains<wbr />Shape</a></li>
  <li><a class="reference" href="#containsBody,Space,Body"
    title="containsBody*(space: Space; body: Body): bool"><wbr />contains<wbr />Body</a></li>
  <li><a class="reference" href="#containsConstraint,Space,Constraint"
    title="containsConstraint*(space: Space; constraint: Constraint): bool"><wbr />contains<wbr />Constraint</a></li>
  <li><a class="reference" href="#addPostStepCallback,Space,PostStepFunc,pointer,pointer"
    title="addPostStepCallback*(space: Space; `func`: PostStepFunc; key: pointer; data: pointer): bool"><wbr />add<wbr />Post<wbr />Step<wbr />Callback</a></li>
  <li><a class="reference" href="#pointQuery,Space,Vect,Float,ShapeFilter,SpacePointQueryFunc,pointer"
    title="pointQuery*(space: Space; point: Vect; maxDistance: Float; filter: ShapeFilter;
            `func`: SpacePointQueryFunc; data: pointer)"><wbr />point<wbr />Query</a></li>
  <li><a class="reference" href="#pointQueryNearest,Space,Vect,Float,ShapeFilter,ptr.PointQueryInfo"
    title="pointQueryNearest*(space: Space; point: Vect; maxDistance: Float; filter: ShapeFilter;
                   `out`: ptr PointQueryInfo): Shape"><wbr />point<wbr />Query<wbr />Nearest</a></li>
  <li><a class="reference" href="#segmentQuery,Space,Vect,Vect,Float,ShapeFilter,SpaceSegmentQueryFunc,pointer"
    title="segmentQuery*(space: Space; start: Vect; `end`: Vect; radius: Float;
              filter: ShapeFilter; `func`: SpaceSegmentQueryFunc; data: pointer)"><wbr />segment<wbr />Query</a></li>
  <li><a class="reference" href="#segmentQueryFirst,Space,Vect,Vect,Float,ShapeFilter,ptr.SegmentQueryInfo"
    title="segmentQueryFirst*(space: Space; start: Vect; `end`: Vect; radius: Float;
                   filter: ShapeFilter; `out`: ptr SegmentQueryInfo): Shape"><wbr />segment<wbr />Query<wbr />First</a></li>
  <li><a class="reference" href="#bBQuery,Space,BB,ShapeFilter,SpaceBBQueryFunc,pointer"
    title="bBQuery*(space: Space; bb: BB; filter: ShapeFilter; `func`: SpaceBBQueryFunc;
         data: pointer)"><wbr />b<wbr />BQuery</a></li>
  <li><a class="reference" href="#shapeQuery,Space,Shape,SpaceShapeQueryFunc,pointer"
    title="shapeQuery*(space: Space; shape: Shape; `func`: SpaceShapeQueryFunc; data: pointer): bool"><wbr />shape<wbr />Query</a></li>
  <li><a class="reference" href="#eachBody,Space,SpaceBodyIteratorFunc,pointer"
    title="eachBody*(space: Space; `func`: SpaceBodyIteratorFunc; data: pointer)"><wbr />each<wbr />Body</a></li>
  <li><a class="reference" href="#eachShape,Space,SpaceShapeIteratorFunc,pointer"
    title="eachShape*(space: Space; `func`: SpaceShapeIteratorFunc; data: pointer)"><wbr />each<wbr />Shape</a></li>
  <li><a class="reference" href="#eachConstraint,Space,SpaceConstraintIteratorFunc,pointer"
    title="eachConstraint*(space: Space; `func`: SpaceConstraintIteratorFunc; data: pointer)"><wbr />each<wbr />Constraint</a></li>
  <li><a class="reference" href="#reindexStatic,Space"
    title="reindexStatic*(space: Space)"><wbr />reindex<wbr />Static</a></li>
  <li><a class="reference" href="#reindexShape,Space,Shape"
    title="reindexShape*(space: Space; shape: Shape)"><wbr />reindex<wbr />Shape</a></li>
  <li><a class="reference" href="#reindexShapesForBody,Space,Body"
    title="reindexShapesForBody*(space: Space; body: Body)"><wbr />reindex<wbr />Shapes<wbr />For<wbr />Body</a></li>
  <li><a class="reference" href="#useSpatialHash,Space,Float,cint"
    title="useSpatialHash*(space: Space; dim: Float; count: cint)"><wbr />use<wbr />Spatial<wbr />Hash</a></li>
  <li><a class="reference" href="#step,Space,Float"
    title="step*(space: Space; dt: Float)"><wbr />step</a></li>
  <li><a class="reference" href="#debugDraw,Space,ptr.SpaceDebugDrawOptions"
    title="debugDraw*(space: Space; options: ptr SpaceDebugDrawOptions)"><wbr />debug<wbr />Draw</a></li>
  <li><a class="reference" href="#momentForCircle,Float,Float,Float,Vect"
    title="momentForCircle*(m: Float; r1: Float; r2: Float; offset: Vect): Float"><wbr />moment<wbr />For<wbr />Circle</a></li>
  <li><a class="reference" href="#areaForCircle,Float,Float"
    title="areaForCircle*(r1: Float; r2: Float): Float"><wbr />area<wbr />For<wbr />Circle</a></li>
  <li><a class="reference" href="#momentForSegment,Float,Vect,Vect,Float"
    title="momentForSegment*(m: Float; a: Vect; b: Vect; radius: Float): Float"><wbr />moment<wbr />For<wbr />Segment</a></li>
  <li><a class="reference" href="#areaForSegment,Vect,Vect,Float"
    title="areaForSegment*(a: Vect; b: Vect; radius: Float): Float"><wbr />area<wbr />For<wbr />Segment</a></li>
  <li><a class="reference" href="#momentForPoly,Float,cint,ptr.Vect,Vect,Float"
    title="momentForPoly*(m: Float; count: cint; verts: ptr Vect; offset: Vect; radius: Float): Float"><wbr />moment<wbr />For<wbr />Poly</a></li>
  <li><a class="reference" href="#areaForPoly,cint,ptr.Vect,Float"
    title="areaForPoly*(count: cint; verts: ptr Vect; radius: Float): Float"><wbr />area<wbr />For<wbr />Poly</a></li>
  <li><a class="reference" href="#centroidForPoly,cint,ptr.Vect"
    title="centroidForPoly*(count: cint; verts: ptr Vect): Vect"><wbr />centroid<wbr />For<wbr />Poly</a></li>
  <li><a class="reference" href="#momentForBox,Float,Float,Float"
    title="momentForBox*(m: Float; width: Float; height: Float): Float"><wbr />moment<wbr />For<wbr />Box</a></li>
  <li><a class="reference" href="#momentForBox,Float,BB"
    title="momentForBox*(m: Float; box: BB): Float"><wbr />moment<wbr />For<wbr />Box</a></li>
  <li><a class="reference" href="#convexHull,cint,ptr.Vect,ptr.Vect,ptr.cint,Float"
    title="convexHull*(count: cint; verts: ptr Vect; result: ptr Vect; first: ptr cint; tol: Float): cint"><wbr />convex<wbr />Hull</a></li>
  <li><a class="reference" href="#closestPointOnSegment,Vect,Vect,Vect"
    title="closestPointOnSegment*(p: Vect; a: Vect; b: Vect): Vect"><wbr />closest<wbr />Point<wbr />On<wbr />Segment</a></li>
  <li><a class="reference" href="#,Vect,Float"
    title="`*`*(v: Vect; s: Float): Vect">`<wbr />*`</a></li>
  <li><a class="reference" href="#+,Vect,Vect"
    title="`+`*(v1, v2: Vect): Vect">`<wbr />+`</a></li>
  <li><a class="reference" href="#-,Vect,Vect"
    title="`-`*(v1, v2: Vect): Vect">`<wbr />-`</a></li>
  <li><a class="reference" href="#==,Vect,Vect"
    title="`==`*(v1, v2: Vect): bool">`<wbr />==`</a></li>
  <li><a class="reference" href="#-,Vect"
    title="`-`*(v: Vect): Vect">`<wbr />-`</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"></p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="math.html">math</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<dt id="Float"><a name="Float"></a><pre><span class="Identifier">Float</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">cdouble</span></pre></dt>
<dd>
Chipmunk's floating point type.

</dd>
<dt id="HashValue"><a name="HashValue"></a><pre><span class="Identifier">HashValue</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>
Hash value type.

</dd>
<dt id="CollisionID"><a name="CollisionID"></a><pre><span class="Identifier">CollisionID</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">uint32</span></pre></dt>
<dd>
Type used internally to cache colliding object info for cpCollideShapes(). Should be at least 32 bits.

</dd>
<dt id="DataPointer"><a name="DataPointer"></a><pre><span class="Identifier">DataPointer</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>
Type used for user data pointers.

</dd>
<dt id="CollisionType"><a name="CollisionType"></a><pre><span class="Identifier">CollisionType</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>
Type used for cpSpace.collision_type.

</dd>
<dt id="Group"><a name="Group"></a><pre><span class="Identifier">Group</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>
Type used for cpShape.group.

</dd>
<dt id="Bitmask"><a name="Bitmask"></a><pre><span class="Identifier">Bitmask</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">cuint</span></pre></dt>
<dd>
Type used for cpShapeFilter category and mask.

</dd>
<dt id="Timestamp"><a name="Timestamp"></a><pre><span class="Identifier">Timestamp</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">cuint</span></pre></dt>
<dd>
Type used for various timestamps in Chipmunk.

</dd>
<dt id="Vect"><a name="Vect"></a><pre><span class="Identifier">Vect</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">y</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
</pre></dt>
<dd>
Chipmunk's 2D vector type.

</dd>
<dt id="Transform"><a name="Transform"></a><pre><span class="Identifier">Transform</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">a</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">b</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">c</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">d</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">tx</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">ty</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
</pre></dt>
<dd>
Column major affine transform.

</dd>
<dt id="Mat2x2"><a name="Mat2x2"></a><pre><span class="Identifier">Mat2x2</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">a</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">b</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">c</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">d</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
</pre></dt>
<dd>


</dd>
<dt id="Array"><a name="Array"></a><pre><span class="Identifier">Array</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="HashSet"><a name="HashSet"></a><pre><span class="Identifier">HashSet</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="Body"><a name="Body"></a><pre><span class="Identifier">Body</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="Shape"><a name="Shape"></a><pre><span class="Identifier">Shape</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Identifier">ShapeObj</span></pre></dt>
<dd>


</dd>
<dt id="CircleShape"><a name="CircleShape"></a><pre><span class="Identifier">CircleShape</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Shape</span></pre></dt>
<dd>


</dd>
<dt id="SegmentShape"><a name="SegmentShape"></a><pre><span class="Identifier">SegmentShape</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Shape</span></pre></dt>
<dd>


</dd>
<dt id="PolyShape"><a name="PolyShape"></a><pre><span class="Identifier">PolyShape</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Shape</span></pre></dt>
<dd>


</dd>
<dt id="Constraint"><a name="Constraint"></a><pre><span class="Identifier">Constraint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Identifier">ConstraintObj</span></pre></dt>
<dd>


</dd>
<dt id="PinJoint"><a name="PinJoint"></a><pre><span class="Identifier">PinJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="SlideJoint"><a name="SlideJoint"></a><pre><span class="Identifier">SlideJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="PivotJoint"><a name="PivotJoint"></a><pre><span class="Identifier">PivotJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="GrooveJoint"><a name="GrooveJoint"></a><pre><span class="Identifier">GrooveJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="DampedSpring"><a name="DampedSpring"></a><pre><span class="Identifier">DampedSpring</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="DampedRotarySpring"><a name="DampedRotarySpring"></a><pre><span class="Identifier">DampedRotarySpring</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="RotaryLimitJoint"><a name="RotaryLimitJoint"></a><pre><span class="Identifier">RotaryLimitJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="RatchetJoint"><a name="RatchetJoint"></a><pre><span class="Identifier">RatchetJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="GearJoint"><a name="GearJoint"></a><pre><span class="Identifier">GearJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span></pre></dt>
<dd>


</dd>
<dt id="SimpleMotorJoint"><a name="SimpleMotorJoint"></a><pre><span class="Identifier">SimpleMotorJoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="Arbiter"><a name="Arbiter"></a><pre><span class="Identifier">Arbiter</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="Space"><a name="Space"></a><pre><span class="Identifier">Space</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span></pre></dt>
<dd>


</dd>
<dt id="BB"><a name="BB"></a><pre><span class="Identifier">BB</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">l</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">b</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">r</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
  <span class="Identifier">t</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>
</pre></dt>
<dd>
Chipmunk's axis-aligned 2D bounding box type. (left, bottom, right, top)

</dd>
<dt id="SpatialIndexBBFunc"><a name="SpatialIndexBBFunc"></a><pre><span class="Identifier">SpatialIndexBBFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spatial index bounding box callback function type. The spatial index calls this function and passes you a pointer to an object you added when it needs to get the bounding box associated with that object.

</dd>
<dt id="SpatialIndexIteratorFunc"><a name="SpatialIndexIteratorFunc"></a><pre><span class="Identifier">SpatialIndexIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spatial index/object iterator callback function type.

</dd>
<dt id="SpatialIndexQueryFunc"><a name="SpatialIndexQueryFunc"></a><pre><span class="Identifier">SpatialIndexQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">obj1</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">obj2</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">id</span><span class="Other">:</span> <span class="Identifier">CollisionID</span><span class="Other">;</span>
                            <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CollisionID</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spatial query callback function type.

</dd>
<dt id="SpatialIndexSegmentQueryFunc"><a name="SpatialIndexSegmentQueryFunc"></a><pre><span class="Identifier">SpatialIndexSegmentQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">obj1</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">obj2</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spatial segment query callback function type.

</dd>
<dt id="SpatialIndex"><a name="SpatialIndex"></a><pre><span class="Identifier">SpatialIndex</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Identifier">SpatialIndexObj</span></pre></dt>
<dd>


</dd>
<dt id="SpaceHash"><a name="SpaceHash"></a><pre><span class="Identifier">SpaceHash</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">SpatialIndex</span></pre></dt>
<dd>


</dd>
<dt id="BBTree"><a name="BBTree"></a><pre><span class="Identifier">BBTree</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">SpatialIndex</span></pre></dt>
<dd>


</dd>
<dt id="BBTreeVelocityFunc"><a name="BBTreeVelocityFunc"></a><pre><span class="Identifier">BBTreeVelocityFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Bounding box tree velocity callback function. This function should return an estimate for the object's velocity.

</dd>
<dt id="Sweep1D"><a name="Sweep1D"></a><pre><span class="Identifier">Sweep1D</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">SpatialIndex</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexDestroyImpl"><a name="SpatialIndexDestroyImpl"></a><pre><span class="Identifier">SpatialIndexDestroyImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexCountImpl"><a name="SpatialIndexCountImpl"></a><pre><span class="Identifier">SpatialIndexCountImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexEachImpl"><a name="SpatialIndexEachImpl"></a><pre><span class="Identifier">SpatialIndexEachImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexIteratorFunc</span><span class="Other">;</span>
                           <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexContainsImpl"><a name="SpatialIndexContainsImpl"></a><pre><span class="Identifier">SpatialIndexContainsImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexInsertImpl"><a name="SpatialIndexInsertImpl"></a><pre><span class="Identifier">SpatialIndexInsertImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexRemoveImpl"><a name="SpatialIndexRemoveImpl"></a><pre><span class="Identifier">SpatialIndexRemoveImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexReindexImpl"><a name="SpatialIndexReindexImpl"></a><pre><span class="Identifier">SpatialIndexReindexImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexReindexObjectImpl"><a name="SpatialIndexReindexObjectImpl"></a><pre><span class="Identifier">SpatialIndexReindexObjectImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                    <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexReindexQueryImpl"><a name="SpatialIndexReindexQueryImpl"></a><pre><span class="Identifier">SpatialIndexReindexQueryImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span>
                                   <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexQueryImpl"><a name="SpatialIndexQueryImpl"></a><pre><span class="Identifier">SpatialIndexQueryImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span>
                            <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexSegmentQueryImpl"><a name="SpatialIndexSegmentQueryImpl"></a><pre><span class="Identifier">SpatialIndexSegmentQueryImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                                   <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">t_exit</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                                   <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexSegmentQueryFunc</span><span class="Other">;</span>
                                   <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="SpatialIndexClass"><a name="SpatialIndexClass"></a><pre><span class="Identifier">SpatialIndexClass</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexDestroyImpl</span>
  <span class="Identifier">count</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexCountImpl</span>
  <span class="Identifier">each</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexEachImpl</span>
  <span class="Identifier">contains</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexContainsImpl</span>
  <span class="Identifier">insert</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexInsertImpl</span>
  <span class="Identifier">remove</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexRemoveImpl</span>
  <span class="Identifier">reindex</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexReindexImpl</span>
  <span class="Identifier">reindexObject</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexReindexObjectImpl</span>
  <span class="Identifier">reindexQuery</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexReindexQueryImpl</span>
  <span class="Identifier">query</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryImpl</span>
  <span class="Identifier">segmentQuery</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpatialIndexSegmentQueryImpl</span>
</pre></dt>
<dd>


</dd>
<dt id="ContactPoint"><a name="ContactPoint"></a><pre><span class="Identifier">ContactPoint</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">pointA</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>
  <span class="Identifier">pointB</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>                <span class="Comment">## The position of the contact on the surface of each shape.</span>
  <span class="Identifier">distance</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Comment">## Penetration distance of the two shapes. Overlapping means it will be negative.</span>
                 <span class="Comment">## This value is calculated as cpvdot(cpvsub(point2, point1), normal) and is ignored by cpArbiterSetContactPointSet().</span>
  </pre></dt>
<dd>
Used in ContactPointSet

</dd>
<dt id="ContactPointSet"><a name="ContactPointSet"></a><pre><span class="Identifier">ContactPointSet</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">count</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                 <span class="Comment">## The number of contact points in the set.</span>
  <span class="Identifier">normal</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>                <span class="Comment">## The normal of the collision.</span>
  <span class="Identifier">points</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">2</span><span class="Other">,</span> <span class="Identifier">ContactPoint</span><span class="Other">]</span> <span class="Comment">## The array of contact points.</span>
  </pre></dt>
<dd>
A struct that wraps up the important collision data for an arbiter.

</dd>
<dt id="BodyType"><a name="BodyType"></a><pre><span class="Identifier">BodyType</span><span class="Operator">*</span> <span class="Other">{.</span><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">sizeof</span><span class="Other">(</span><span class="Identifier">cint</span><span class="Other">)</span><span class="Other">.}</span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">BODY_TYPE_DYNAMIC</span><span class="Other">,</span> <span class="Comment">## A dynamic body is one that is affected by gravity, forces, and collisions.</span>
                    <span class="Comment">## This is the default body type.</span>
  <span class="Identifier">BODY_TYPE_KINEMATIC</span><span class="Other">,</span> <span class="Comment">## A kinematic body is an infinite mass, user controlled body that is not affected by gravity, forces or collisions.</span>
                      <span class="Comment">## Instead the body only moves based on it's velocity.</span>
                      <span class="Comment">## Dynamic bodies collide normally with kinematic bodies, though the kinematic body will be unaffected.</span>
                      <span class="Comment">## Collisions between two kinematic bodies, or a kinematic body and a static body produce collision callbacks, but no collision response.</span>
  <span class="Identifier">BODY_TYPE_STATIC</span> <span class="Comment">## A static body is a body that never (or rarely) moves. If you move a static body, you must call one of the cpSpaceReindex*() functions.</span>
                  <span class="Comment">## Chipmunk uses this information to optimize the collision detection.</span>
                  <span class="Comment">## Static bodies do not produce collision callbacks when colliding with other static bodies.</span></pre></dt>
<dd>


</dd>
<dt id="BodyVelocityFunc"><a name="BodyVelocityFunc"></a><pre><span class="Identifier">BodyVelocityFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">gravity</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">dt</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Rigid body velocity update function type.

</dd>
<dt id="BodyPositionFunc"><a name="BodyPositionFunc"></a><pre><span class="Identifier">BodyPositionFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">dt</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Rigid body position update function type.

</dd>
<dt id="BodyShapeIteratorFunc"><a name="BodyShapeIteratorFunc"></a><pre><span class="Identifier">BodyShapeIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> once for each shape attached to <cite>body</cite> and added to the space.

</dd>
<dt id="BodyConstraintIteratorFunc"><a name="BodyConstraintIteratorFunc"></a><pre><span class="Identifier">BodyConstraintIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Body/constraint iterator callback function type.

</dd>
<dt id="BodyArbiterIteratorFunc"><a name="BodyArbiterIteratorFunc"></a><pre><span class="Identifier">BodyArbiterIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">arbiter</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Body/arbiter iterator callback function type.

</dd>
<dt id="PointQueryInfo"><a name="PointQueryInfo"></a><pre><span class="Identifier">PointQueryInfo</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">shape</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Shape</span>                <span class="Comment">## The nearest shape, NULL if no shape was within range.</span>
  <span class="Identifier">point</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>                 <span class="Comment">## The closest point on the shape's surface. (in world space coordinates)</span>
  <span class="Identifier">distance</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>             <span class="Comment">## The distance to the point. The distance is negative if the point is inside the shape.</span>
  <span class="Identifier">gradient</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>              <span class="Comment">## The gradient of the signed distance function.</span>
                <span class="Comment">## The value should be similar to info.p/info.d, but accurate even for very small values of info.d.</span>
  </pre></dt>
<dd>
Point query info struct.

</dd>
<dt id="SegmentQueryInfo"><a name="SegmentQueryInfo"></a><pre><span class="Identifier">SegmentQueryInfo</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">shape</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Shape</span>                <span class="Comment">## The shape that was hit, or NULL if no collision occured.</span>
  <span class="Identifier">point</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>                 <span class="Comment">## The point of impact.</span>
  <span class="Identifier">normal</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Vect</span>                <span class="Comment">## The normal of the surface hit.</span>
  <span class="Identifier">alpha</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Float</span>                <span class="Comment">## The normalized distance along the query segment in the range [0, 1].</span>
  </pre></dt>
<dd>
Segment query info struct.

</dd>
<dt id="ShapeFilter"><a name="ShapeFilter"></a><pre><span class="Identifier">ShapeFilter</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">group</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Group</span> <span class="Comment">## Two objects with the same non-zero group value do not collide.</span>
              <span class="Comment">## This is generally used to group objects in a composite object together to disable self collisions.</span>
  <span class="Identifier">categories</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Bitmask</span> <span class="Comment">## A bitmask of user definable categories that this object belongs to.</span>
                     <span class="Comment">## The category/mask combinations of both objects in a collision must agree for a collision to occur.</span>
  <span class="Identifier">mask</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Bitmask</span> <span class="Comment">## A bitmask of user definable category types that this object object collides with.</span>
               <span class="Comment">## The category/mask combinations of both objects in a collision must agree for a collision to occur.</span>
  </pre></dt>
<dd>
Fast collision filtering type that is used to determine if two objects collide before calling collision or query callbacks.

</dd>
<dt id="ConstraintPreSolveFunc"><a name="ConstraintPreSolveFunc"></a><pre><span class="Identifier">ConstraintPreSolveFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback function type that gets called before solving a joint.

</dd>
<dt id="ConstraintPostSolveFunc"><a name="ConstraintPostSolveFunc"></a><pre><span class="Identifier">ConstraintPostSolveFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback function type that gets called after solving a joint.

</dd>
<dt id="DampedSpringForceFunc"><a name="DampedSpringForceFunc"></a><pre><span class="Identifier">DampedSpringForceFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">spring</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">dist</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Function type used for damped spring force callbacks.

</dd>
<dt id="DampedRotarySpringTorqueFunc"><a name="DampedRotarySpringTorqueFunc"></a><pre><span class="Identifier">DampedRotarySpringTorqueFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">spring</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">relativeAngle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Function type used for damped rotary spring force callbacks.

</dd>
<dt id="SimpleMotor"><a name="SimpleMotor"></a><pre><span class="Identifier">SimpleMotor</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Constraint</span>
  </pre></dt>
<dd>
Opaque struct type for damped rotary springs.

</dd>
<dt id="CollisionBeginFunc"><a name="CollisionBeginFunc"></a><pre><span class="Identifier">CollisionBeginFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Collision begin event function callback type. Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding.

</dd>
<dt id="CollisionPreSolveFunc"><a name="CollisionPreSolveFunc"></a><pre><span class="Identifier">CollisionPreSolveFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Collision pre-solve event function callback type. Returning false from a pre-step callback causes the collision to be ignored until the next step.

</dd>
<dt id="CollisionPostSolveFunc"><a name="CollisionPostSolveFunc"></a><pre><span class="Identifier">CollisionPostSolveFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Collision post-solve event function callback type.

</dd>
<dt id="CollisionSeparateFunc"><a name="CollisionSeparateFunc"></a><pre><span class="Identifier">CollisionSeparateFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Collision separate event function callback type.

</dd>
<dt id="CollisionHandler"><a name="CollisionHandler"></a><pre><span class="Identifier">CollisionHandler</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">typeA</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionType</span> <span class="Comment">## Collision type identifier of the first shape that this handler recognizes.</span>
                      <span class="Comment">## In the collision handler callback, the shape with this type will be the first argument. Read only.</span>
  <span class="Identifier">typeB</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionType</span> <span class="Comment">## Collision type identifier of the second shape that this handler recognizes.</span>
                      <span class="Comment">## In the collision handler callback, the shape with this type will be the second argument. Read only.</span>
  <span class="Identifier">beginFunc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionBeginFunc</span> <span class="Comment">## This function is called when two shapes with types that match this collision handler begin colliding.</span>
  <span class="Identifier">preSolveFunc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionPreSolveFunc</span> <span class="Comment">## This function is called each step when two shapes with types that match this collision handler are colliding.</span>
                                     <span class="Comment">## It's called before the collision solver runs so that you can affect a collision's outcome.</span>
  <span class="Identifier">postSolveFunc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionPostSolveFunc</span> <span class="Comment">## This function is called each step when two shapes with types that match this collision handler are colliding.</span>
                                       <span class="Comment">## It's called after the collision solver runs so that you can read back information about the collision to trigger events in your game.</span>
  <span class="Identifier">separateFunc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">CollisionSeparateFunc</span> <span class="Comment">## This function is called when two shapes with types that match this collision handler stop colliding.</span>
  <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">DataPointer</span>       <span class="Comment">## This is a user definable context pointer that is passed to all of the collision handler functions.</span>
  </pre></dt>
<dd>
Struct that holds function callback pointers to configure custom collision handling. Collision handlers have a pair of types; when a collision occurs between two shapes that have these types, the collision handler functions are triggered.

</dd>
<dt id="PostStepFunc"><a name="PostStepFunc"></a><pre><span class="Identifier">PostStepFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Post Step callback function type.

</dd>
<dt id="SpacePointQueryFunc"><a name="SpacePointQueryFunc"></a><pre><span class="Identifier">SpacePointQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">distance</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">gradient</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                          <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Nearest point query callback function type.

</dd>
<dt id="SpaceSegmentQueryFunc"><a name="SpaceSegmentQueryFunc"></a><pre><span class="Identifier">SpaceSegmentQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">normal</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">alpha</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                            <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Segment query callback function type.

</dd>
<dt id="SpaceBBQueryFunc"><a name="SpaceBBQueryFunc"></a><pre><span class="Identifier">SpaceBBQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Rectangle Query callback function type.

</dd>
<dt id="SpaceShapeQueryFunc"><a name="SpaceShapeQueryFunc"></a><pre><span class="Identifier">SpaceShapeQueryFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">points</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">ContactPointSet</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Shape query callback function type.

</dd>
<dt id="SpaceBodyIteratorFunc"><a name="SpaceBodyIteratorFunc"></a><pre><span class="Identifier">SpaceBodyIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Space/body iterator callback function type.

</dd>
<dt id="SpaceShapeIteratorFunc"><a name="SpaceShapeIteratorFunc"></a><pre><span class="Identifier">SpaceShapeIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Space/body iterator callback function type.

</dd>
<dt id="SpaceConstraintIteratorFunc"><a name="SpaceConstraintIteratorFunc"></a><pre><span class="Identifier">SpaceConstraintIteratorFunc</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Space/constraint iterator callback function type.

</dd>
<dt id="SpaceDebugColor"><a name="SpaceDebugColor"></a><pre><span class="Identifier">SpaceDebugColor</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">r</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cfloat</span>
  <span class="Identifier">g</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cfloat</span>
  <span class="Identifier">b</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cfloat</span>
  <span class="Identifier">a</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cfloat</span>
</pre></dt>
<dd>
Color type to use with the space debug drawing API.

</dd>
<dt id="SpaceDebugDrawCircleImpl"><a name="SpaceDebugDrawCircleImpl"></a><pre><span class="Identifier">SpaceDebugDrawCircleImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">pos</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">angle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                               <span class="Identifier">outlineColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span>
                               <span class="Identifier">fillColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that draws a filled, stroked circle.

</dd>
<dt id="SpaceDebugDrawSegmentImpl"><a name="SpaceDebugDrawSegmentImpl"></a><pre><span class="Identifier">SpaceDebugDrawSegmentImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">color</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span>
                                <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that draws a line segment.

</dd>
<dt id="SpaceDebugDrawFatSegmentImpl"><a name="SpaceDebugDrawFatSegmentImpl"></a><pre><span class="Identifier">SpaceDebugDrawFatSegmentImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                                   <span class="Identifier">outlineColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span>
                                   <span class="Identifier">fillColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that draws a thick line segment.

</dd>
<dt id="SpaceDebugDrawPolygonImpl"><a name="SpaceDebugDrawPolygonImpl"></a><pre><span class="Identifier">SpaceDebugDrawPolygonImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                                <span class="Identifier">outlineColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span>
                                <span class="Identifier">fillColor</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that draws a convex polygon.

</dd>
<dt id="SpaceDebugDrawDotImpl"><a name="SpaceDebugDrawDotImpl"></a><pre><span class="Identifier">SpaceDebugDrawDotImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">pos</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">color</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span><span class="Other">;</span>
                            <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that draws a dot.

</dd>
<dt id="SpaceDebugDrawColorForShapeImpl"><a name="SpaceDebugDrawColorForShapeImpl"></a><pre><span class="Identifier">SpaceDebugDrawColorForShapeImpl</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Callback type for a function that returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine.

</dd>
<dt id="SpaceDebugDrawFlags"><a name="SpaceDebugDrawFlags"></a><pre><span class="Identifier">SpaceDebugDrawFlags</span><span class="Operator">*</span> <span class="Other">{.</span><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">sizeof</span><span class="Other">(</span><span class="Identifier">cint</span><span class="Other">)</span><span class="Other">.}</span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">SPACE_DEBUG_DRAW_SHAPES</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">SPACE_DEBUG_DRAW_CONSTRAINTS</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">1</span><span class="Other">,</span>
  <span class="Identifier">SPACE_DEBUG_DRAW_COLLISION_POINTS</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">2</span></pre></dt>
<dd>


</dd>
<dt id="SpaceDebugDrawOptions"><a name="SpaceDebugDrawOptions"></a><pre><span class="Identifier">SpaceDebugDrawOptions</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">drawCircle</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawCircleImpl</span> <span class="Comment">## Function that will be invoked to draw circles.</span>
  <span class="Identifier">drawSegment</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawSegmentImpl</span> <span class="Comment">## Function that will be invoked to draw line segments.</span>
  <span class="Identifier">drawFatSegment</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawFatSegmentImpl</span> <span class="Comment">## Function that will be invoked to draw thick line segments.</span>
  <span class="Identifier">drawPolygon</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawPolygonImpl</span> <span class="Comment">## Function that will be invoked to draw convex polygons.</span>
  <span class="Identifier">drawDot</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawDotImpl</span> <span class="Comment">## Function that will be invoked to draw dots.</span>
  <span class="Identifier">flags</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawFlags</span>  <span class="Comment">## Flags that request which things to draw (collision shapes, constraints, contact points).</span>
  <span class="Identifier">shapeOutlineColor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span> <span class="Comment">## Outline color passed to the drawing function.</span>
  <span class="Identifier">colorForShape</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugDrawColorForShapeImpl</span> <span class="Comment">## Function that decides what fill color to draw shapes using.</span>
  <span class="Identifier">constraintColor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span> <span class="Comment">## Color passed to drawing functions for constraints.</span>
  <span class="Identifier">collisionPointColor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">SpaceDebugColor</span> <span class="Comment">## Color passed to drawing functions for collision points.</span>
  <span class="Identifier">data</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">DataPointer</span>           <span class="Comment">## User defined context pointer passed to all of the callback functions as the 'data' argument.</span>
  </pre></dt>
<dd>
Struct used with cpSpaceDebugDraw() containing drawing callbacks and other drawing settings.

</dd>

</dl></div>
<div class="section" id="8">
<h1><a class="toc-backref" href="#8">Vars</a></h1>
<dl class="item">
<dt id="vzero"><a name="vzero"></a><pre><span class="Identifier">vzero</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">Vect</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">,</span> <span class="Identifier">y</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">)</span></pre></dt>
<dd>
Constant for the zero vector.

</dd>
<dt id="TransformIdentity"><a name="TransformIdentity"></a><pre><span class="Identifier">TransformIdentity</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">Transform</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="FloatNumber">1.0'f64</span><span class="Other">,</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">,</span> <span class="Identifier">c</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">,</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="FloatNumber">1.0'f64</span><span class="Other">,</span>
                             <span class="Identifier">tx</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">,</span> <span class="Identifier">ty</span><span class="Other">:</span> <span class="FloatNumber">0.0'f64</span><span class="Other">)</span></pre></dt>
<dd>
Identity transform matrix.

</dd>
<dt id="SHAPE_FILTER_ALL"><a name="SHAPE_FILTER_ALL"></a><pre><span class="Identifier">SHAPE_FILTER_ALL</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">ShapeFilter</span><span class="Other">(</span><span class="Identifier">group</span><span class="Other">:</span> <span class="Other">(</span><span class="Keyword">cast</span><span class="Other">[</span><span class="Identifier">Group</span><span class="Other">]</span><span class="Other">(</span><span class="DecNumber">0</span><span class="Other">)</span><span class="Other">)</span><span class="Other">)</span></pre></dt>
<dd>
Collision filter value for a shape that will collide with anything except CP_SHAPE_FILTER_NONE.

</dd>
<dt id="SHAPE_FILTER_NONE"><a name="SHAPE_FILTER_NONE"></a><pre><span class="Identifier">SHAPE_FILTER_NONE</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">ShapeFilter</span><span class="Other">(</span><span class="Identifier">group</span><span class="Other">:</span> <span class="Other">(</span><span class="Keyword">cast</span><span class="Other">[</span><span class="Identifier">Group</span><span class="Other">]</span><span class="Other">(</span><span class="DecNumber">0</span><span class="Other">)</span><span class="Other">)</span><span class="Other">)</span></pre></dt>
<dd>
Collision filter value for a shape that does not collide with anything.

</dd>
<dt id="VersionString"><a name="VersionString"></a><pre><span class="Identifier">VersionString</span><span class="Operator">*</span> <span class="Other">{.</span><span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpVersionString&quot;</span><span class="Other">.}</span><span class="Other">:</span> <span class="Identifier">cstring</span></pre></dt>
<dd>
Version string.

</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="message"><a name="message,cstring,cstring,cint,cint,cint,cstring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">message</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">condition</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">file</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">line</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">isError</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
             <span class="Identifier">isHardError</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">message</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">varargs</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMessage&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="fmax"><a name="fmax,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">fmax</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Return the max of two cpFloats

</dd>
<dt id="fmin"><a name="fmin,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">fmin</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Return the min of two cpFloats

</dd>
<dt id="fabs"><a name="fabs,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">fabs</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">f</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Return the absolute value of a cpFloat.

</dd>
<dt id="fclamp"><a name="fclamp,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">fclamp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">f</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Clamp <cite>f</cite> to be between <cite>min</cite> and <cite>max</cite>.

</dd>
<dt id="fclamp01"><a name="fclamp01,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">fclamp01</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">f</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Clamp <cite>f</cite> to be between 0 and 1.

</dd>
<dt id="flerp"><a name="flerp,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">flerp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">f1</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">f2</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Linearly interpolate (or extrapolate) between <cite>f1</cite> and <cite>f2</cite> by <cite>t</cite> percent.

</dd>
<dt id="flerpconst"><a name="flerpconst,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">flerpconst</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">f1</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">f2</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Linearly interpolate from <cite>f1</cite> to <cite>f2</cite> by no more than <cite>d</cite>.

</dd>
<dt id="v"><a name="v,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">v</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">y</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience constructor for cpVect structs.

</dd>
<dt id="veql"><a name="veql,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">veql</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Check if two vectors are equal. (Be careful when comparing floating point numbers!)

</dd>
<dt id="vadd"><a name="vadd,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vadd</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Add two vectors

</dd>
<dt id="vsub"><a name="vsub,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vsub</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Subtract two vectors.

</dd>
<dt id="vneg"><a name="vneg,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vneg</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Negate a vector.

</dd>
<dt id="vmult"><a name="vmult,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vmult</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">s</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Scalar multiplication.

</dd>
<dt id="vdot"><a name="vdot,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vdot</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Vector dot product.

</dd>
<dt id="vcross"><a name="vcross,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vcross</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
2D vector cross product analog. The cross product of 2D vectors results in a 3D vector with only a z component. This function returns the magnitude of the z value.

</dd>
<dt id="vperp"><a name="vperp,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vperp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a perpendicular vector. (90 degree rotation)

</dd>
<dt id="vrperp"><a name="vrperp,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vrperp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a perpendicular vector. (-90 degree rotation)

</dd>
<dt id="vproject"><a name="vproject,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vproject</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the vector projection of v1 onto v2.

</dd>
<dt id="vforangle"><a name="vforangle,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vforangle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the unit length vector for the given angle (in radians).

</dd>
<dt id="vtoangle"><a name="vtoangle,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vtoangle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the angular direction v is pointing in (in radians).

</dd>
<dt id="vrotate"><a name="vrotate,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vrotate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector.

</dd>
<dt id="vunrotate"><a name="vunrotate,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vunrotate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Inverse of cpvrotate().

</dd>
<dt id="vlengthsq"><a name="vlengthsq,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vlengthsq</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the squared length of v. Faster than cpvlength() when you only need to compare lengths.

</dd>
<dt id="vlength"><a name="vlength,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vlength</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the length of v.

</dd>
<dt id="vlerp"><a name="vlerp,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vlerp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Linearly interpolate between v1 and v2.

</dd>
<dt id="vnormalize"><a name="vnormalize,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vnormalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a normalized copy of v.

</dd>
<dt id="vslerp"><a name="vslerp,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vslerp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spherical linearly interpolate between v1 and v2.

</dd>
<dt id="vslerpconst"><a name="vslerpconst,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vslerpconst</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Spherical linearly interpolate between v1 towards v2 by no more than angle a radians

</dd>
<dt id="vclamp"><a name="vclamp,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vclamp</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Clamp v to length len.

</dd>
<dt id="vlerpconst"><a name="vlerpconst,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vlerpconst</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Linearly interpolate between v1 towards v2 by distance d.

</dd>
<dt id="vdist"><a name="vdist,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vdist</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the distance between v1 and v2.

</dd>
<dt id="vdistsq"><a name="vdistsq,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vdistsq</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the squared distance between v1 and v2. Faster than cpvdist() when you only need to compare distances.

</dd>
<dt id="vnear"><a name="vnear,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vnear</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">dist</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if the distance between v1 and v2 is less than dist.

</dd>
<dt id="newMat2x2"><a name="newMat2x2,Float,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newMat2x2</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">c</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Mat2x2</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="transform"><a name="transform,Mat2x2,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transform</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Mat2x2</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="newBB"><a name="newBB,Float,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">l</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">r</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience constructor for cpBB structs.

</dd>
<dt id="newForExtentsBB"><a name="newForExtentsBB,Vect,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newForExtentsBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">c</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">hw</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">hh</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Constructs a cpBB centered on a point with the given extents (half sizes).

</dd>
<dt id="newForCircleBB"><a name="newForCircleBB,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newForCircleBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">r</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Constructs a cpBB for a circle with the given position and radius.

</dd>
<dt id="intersects"><a name="intersects,BB,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">intersects</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if <cite>a</cite> and <cite>b</cite> intersect.

</dd>
<dt id="containsBB"><a name="containsBB,BB,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">containsBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">other</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if <cite>other</cite> lies completely within <cite>bb</cite>.

</dd>
<dt id="containsVect"><a name="containsVect,BB,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">containsVect</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if <cite>bb</cite> contains <cite>v</cite>.

</dd>
<dt id="merge"><a name="merge,BB,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">merge</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a bounding box that holds both bounding boxes.

</dd>
<dt id="expand"><a name="expand,BB,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">expand</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a bounding box that holds both <cite>bb</cite> and <cite>v</cite>.

</dd>
<dt id="center"><a name="center,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">center</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the center of a bounding box.

</dd>
<dt id="area"><a name="area,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">area</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the area of the bounding box.

</dd>
<dt id="mergedArea"><a name="mergedArea,BB,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mergedArea</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Merges <cite>a</cite> and <cite>b</cite> and returns the area of the merged bounding box.

</dd>
<dt id="segmentQuery"><a name="segmentQuery,BB,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">segmentQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the fraction along the segment query the cpBB is hit. Returns INFINITY if it doesn't hit.

</dd>
<dt id="intersectsSegment"><a name="intersectsSegment,BB,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">intersectsSegment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Return true if the bounding box intersects the line segment with ends <cite>a</cite> and <cite>b</cite>.

</dd>
<dt id="clampVect"><a name="clampVect,BB,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">clampVect</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Clamp a vector to a bounding box.

</dd>
<dt id="wrapVect"><a name="wrapVect,BB,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">wrapVect</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Wrap a vector to a bounding box.

</dd>
<dt id="offset"><a name="offset,BB,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">offset</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns a bounding box offseted by <cite>v</cite>.

</dd>
<dt id="newTransform"><a name="newTransform,Float,Float,Float,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newTransform</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">c</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">tx</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">ty</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Construct a new transform matrix. (a, b) is the x basis vector. (c, d) is the y basis vector. (tx, ty) is the translation.

</dd>
<dt id="newTransposeTransform"><a name="newTransposeTransform,Float,Float,Float,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newTransposeTransform</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">c</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">tx</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">ty</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Construct a new transform matrix in transposed order.

</dd>
<dt id="inverse"><a name="inverse,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">inverse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Get the inverse of a transform matrix.

</dd>
<dt id="mult"><a name="mult,Transform,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mult</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Multiply two transformation matrices.

</dd>
<dt id="point"><a name="point,Transform,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">point</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">p</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Transform an absolute point. (i.e. a vertex)

</dd>
<dt id="vect"><a name="vect,Transform,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vect</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Transform a vector (i.e. a normal)

</dd>
<dt id="transformBB"><a name="transformBB,Transform,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Transform a cpBB.

</dd>
<dt id="transformTranslate"><a name="transformTranslate,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformTranslate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">translate</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Create a transation matrix.

</dd>
<dt id="transformScale"><a name="transformScale,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformScale</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">scaleX</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">scaleY</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Create a scale matrix.

</dd>
<dt id="transformRotate"><a name="transformRotate,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformRotate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">radians</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Create a rotation matrix.

</dd>
<dt id="transformRigid"><a name="transformRigid,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformRigid</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">translate</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radians</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Create a rigid transformation matrix. (transation + rotation)

</dd>
<dt id="transformRigidInverse"><a name="transformRigidInverse,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformRigidInverse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Fast inverse of a rigid transformation matrix.

</dd>
<dt id="transformWrap"><a name="transformWrap,Transform,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformWrap</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">outer</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">inner</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="transformWrapInverse"><a name="transformWrapInverse,Transform,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformWrapInverse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">outer</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">inner</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="transformOrtho"><a name="transformOrtho,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformOrtho</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="transformBoneScale"><a name="transformBoneScale,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformBoneScale</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v0</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">v1</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="transformAxialScale"><a name="transformAxialScale,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">transformAxialScale</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">axis</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">pivot</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">scale</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Transform</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="allocateSpaceHash"><a name="allocateSpaceHash,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSpaceHash</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpaceHash</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceHashAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a spatial hash.

</dd>
<dt id="initializeSpaceHash"><a name="initializeSpaceHash,SpaceHash,Float,cint,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSpaceHash</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">hash</span><span class="Other">:</span> <span class="Identifier">SpaceHash</span><span class="Other">;</span> <span class="Identifier">celldim</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">numcells</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                         <span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span> <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceHashInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a spatial hash.

</dd>
<dt id="newSpaceHash"><a name="newSpaceHash,Float,cint,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSpaceHash</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">celldim</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">cells</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span>
                  <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpaceHash</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceHashNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a spatial hash.

</dd>
<dt id="resize"><a name="resize,SpaceHash,Float,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">resize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">hash</span><span class="Other">:</span> <span class="Identifier">SpaceHash</span><span class="Other">;</span> <span class="Identifier">celldim</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">numcells</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceHashResize&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Change the cell dimensions and table size of the spatial hash to tune it. The cell dimensions should roughly match the average size of your objects and the table size should be ~10 larger than the number of objects inserted. Some trial and error is required to find the optimum numbers for efficiency.

</dd>
<dt id="allocateBBTree"><a name="allocateBBTree,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateBBTree</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BBTree</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBBTreeAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a bounding box tree.

</dd>
<dt id="initializeBBTree"><a name="initializeBBTree,BBTree,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeBBTree</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">BBTree</span><span class="Other">;</span> <span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span>
                      <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBBTreeInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a bounding box tree.

</dd>
<dt id="newBBTree"><a name="newBBTree,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newBBTree</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span> <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BBTree</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBBTreeNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a bounding box tree.

</dd>
<dt id="optimize"><a name="optimize,BBTree"></a><pre><span class="Keyword">proc</span> <span class="Identifier">optimize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">BBTree</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBBTreeOptimize&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a static top down optimization of the tree.

</dd>
<dt id="="><a name="=,BBTree,BBTreeVelocityFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">velocityFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">BBTree</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">BBTreeVelocityFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBBTreeSetVelocityFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the velocity function for the bounding box tree to enable temporal coherence.

</dd>
<dt id="allocateSweep1D"><a name="allocateSweep1D,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSweep1D</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Sweep1D</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSweep1DAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a 1D sort and sweep broadphase.

</dd>
<dt id="initializeSweep1D"><a name="initializeSweep1D,Sweep1D,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSweep1D</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">sweep</span><span class="Other">:</span> <span class="Identifier">Sweep1D</span><span class="Other">;</span> <span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span>
                       <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSweep1DInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a 1D sort and sweep broadphase.

</dd>
<dt id="newSweep1D"><a name="newSweep1D,SpatialIndexBBFunc,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSweep1D</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">bbfunc</span><span class="Other">:</span> <span class="Identifier">SpatialIndexBBFunc</span><span class="Other">;</span> <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Sweep1D</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSweep1DNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a 1D sort and sweep broadphase.

</dd>
<dt id="destroy"><a name="destroy,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpatialIndexFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy and free a spatial index.

</dd>
<dt id="destroy"><a name="destroy,Sweep1D"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">Sweep1D</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpatialIndexFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,SpaceHash"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpaceHash</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpatialIndexFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,BBTree"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">BBTree</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpatialIndexFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="collideStatic"><a name="collideStatic,SpatialIndex,SpatialIndex,SpatialIndexQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collideStatic</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">dynamicIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">staticIndex</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span>
                   <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpatialIndexCollideStatic&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Collide the objects in <cite>dynamicIndex</cite> against the objects in <cite>staticIndex</cite> using the query callback function.

</dd>
<dt id="finalize"><a name="finalize,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">finalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy a spatial index.

</dd>
<dt id="count"><a name="count,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">count</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Get the number of objects in the spatial index.

</dd>
<dt id="each"><a name="each,SpatialIndex,SpatialIndexIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">each</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Iterate the objects in the spatial index. <cite>func</cite> will be called once for each object.

</dd>
<dt id="contains"><a name="contains,SpatialIndex,pointer,HashValue"></a><pre><span class="Keyword">proc</span> <span class="Identifier">contains</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if the spatial index contains the given object. Most spatial indexes use hashed storage, so you must provide a hash value too.

</dd>
<dt id="insert"><a name="insert,SpatialIndex,pointer,HashValue"></a><pre><span class="Keyword">proc</span> <span class="Identifier">insert</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Add an object to a spatial index. Most spatial indexes use hashed storage, so you must provide a hash value too.

</dd>
<dt id="remove"><a name="remove,SpatialIndex,pointer,HashValue"></a><pre><span class="Keyword">proc</span> <span class="Identifier">remove</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Remove an object from a spatial index. Most spatial indexes use hashed storage, so you must provide a hash value too.

</dd>
<dt id="reindex"><a name="reindex,SpatialIndex"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindex</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a full reindex of a spatial index.

</dd>
<dt id="reindexObject"><a name="reindexObject,SpatialIndex,pointer,HashValue"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindexObject</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">hashid</span><span class="Other">:</span> <span class="Identifier">HashValue</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Reindex a single object in the spatial index.

</dd>
<dt id="query"><a name="query,SpatialIndex,pointer,BB,SpatialIndexQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryFunc</span><span class="Other">;</span>
           <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a rectangle query against the spatial index, calling <cite>func</cite> for each potential match.

</dd>
<dt id="segmentQuery"><a name="segmentQuery,SpatialIndex,pointer,Vect,Vect,Float,SpatialIndexSegmentQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">segmentQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Identifier">obj</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">t_exit</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                  <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexSegmentQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a segment query against the spatial index, calling <cite>func</cite> for each potential match.

</dd>
<dt id="reindexQuery"><a name="reindexQuery,SpatialIndex,SpatialIndexQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindexQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">SpatialIndex</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpatialIndexQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Simultaneously reindex and find all colliding objects. <cite>func</cite> will be called once for each potentially overlapping pair of objects found. If the spatial index was initialized with a static index, it will collide it's objects against that as well.

</dd>
<dt id="restitution"><a name="restitution,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">restitution</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetRestitution&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the restitution (elasticity) that will be applied to the pair of colliding objects.

</dd>
<dt id="="><a name="=,Arbiter,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">restitution</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">restitution</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterSetRestitution&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Override the restitution (elasticity) that will be applied to the pair of colliding objects.

</dd>
<dt id="friction"><a name="friction,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">friction</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetFriction&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the friction coefficient that will be applied to the pair of colliding objects.

</dd>
<dt id="="><a name="=,Arbiter,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">friction</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">friction</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterSetFriction&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Override the friction coefficient that will be applied to the pair of colliding objects.

</dd>
<dt id="surfaceVelocity"><a name="surfaceVelocity,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">surfaceVelocity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
                                        <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetSurfaceVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Arbiter,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">surfaceVelocity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">vr</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterSetSurfaceVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="userData"><a name="userData,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DataPointer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the user data pointer associated with this pair of colliding objects.

</dd>
<dt id="="><a name="=,Arbiter,DataPointer"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">userData</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterSetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set a user data point associated with this pair of colliding objects. If you need to perform any cleanup for this pointer, you must do it yourself, in the separate callback for instance.

</dd>
<dt id="totalImpulse"><a name="totalImpulse,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">totalImpulse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterTotalImpulse&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the total impulse including the friction that was applied by this arbiter. This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.

</dd>
<dt id="totalKE"><a name="totalKE,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">totalKE</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterTotalKE&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the amount of energy lost in a collision including static, but not dynamic friction. This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.

</dd>
<dt id="ignore"><a name="ignore,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">ignore</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterIgnore&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Mark a collision pair to be ignored until the two objects separate. Pre-solve and post-solve callbacks will not be called, but the separate callback will be called.

</dd>
<dt id="shapes"><a name="shapes,Arbiter,ptr.Shape,ptr.Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">shapes</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetShapes&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Return the colliding shapes involved for this arbiter. The order of their cpSpace.collision_type values will match the order set when the collision handler was registered.

</dd>
<dt id="bodies"><a name="bodies,Arbiter,ptr.Body,ptr.Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bodies</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetBodies&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Return the colliding bodies involved for this arbiter. The order of the cpSpace.collision_type the bodies are associated with values will match the order set when the collision handler was registered.

</dd>
<dt id="contactPointSet"><a name="contactPointSet,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">contactPointSet</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ContactPointSet</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetContactPointSet&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Return a contact set from an arbiter.

</dd>
<dt id="="><a name="=,Arbiter,ptr.ContactPointSet"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">contactPointSet</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">set</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">ContactPointSet</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterSetContactPointSet&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Replace the contact point set for an arbiter. This can be a very powerful feature, but use it with caution!

</dd>
<dt id="isFirstContact"><a name="isFirstContact,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isFirstContact</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterIsFirstContact&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if this is the first step a pair of objects started colliding.

</dd>
<dt id="isRemoval"><a name="isRemoval,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isRemoval</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterIsRemoval&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if the separate callback is due to a shape being removed from the space.

</dd>
<dt id="count"><a name="count,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">count</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetCount&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the number of contact points for this arbiter.

</dd>
<dt id="normal"><a name="normal,Arbiter"></a><pre><span class="Keyword">proc</span> <span class="Identifier">normal</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetNormal&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the normal of the collision.

</dd>
<dt id="pointA"><a name="pointA,Arbiter,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pointA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetPointA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the position of the <cite>ith</cite> contact point on the surface of the first shape.

</dd>
<dt id="pointB"><a name="pointB,Arbiter,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pointB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetPointB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the position of the <cite>ith</cite> contact point on the surface of the second shape.

</dd>
<dt id="depth"><a name="depth,Arbiter,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterGetDepth&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the depth of the <cite>ith</cite> contact point.

</dd>
<dt id="callWildcardBeginA"><a name="callWildcardBeginA,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardBeginA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardBeginA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.

</dd>
<dt id="callWildcardBeginB"><a name="callWildcardBeginB,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardBeginB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardBeginB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.

</dd>
<dt id="callWildcardPreSolveA"><a name="callWildcardPreSolveA,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardPreSolveA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardPreSolveA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.

</dd>
<dt id="callWildcardPreSolveB"><a name="callWildcardPreSolveB,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardPreSolveB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardPreSolveB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.

</dd>
<dt id="callWildcardPostSolveA"><a name="callWildcardPostSolveA,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardPostSolveA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardPostSolveA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.

</dd>
<dt id="callWildcardPostSolveB"><a name="callWildcardPostSolveB,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardPostSolveB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardPostSolveB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.

</dd>
<dt id="callWildcardSeparateA"><a name="callWildcardSeparateA,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardSeparateA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardSeparateA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.

</dd>
<dt id="callWildcardSeparateB"><a name="callWildcardSeparateB,Arbiter,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">callWildcardSeparateB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">arb</span><span class="Other">:</span> <span class="Identifier">Arbiter</span><span class="Other">;</span> <span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpArbiterCallWildcardSeparateB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.

</dd>
<dt id="allocateBody"><a name="allocateBody,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a cpBody.

</dd>
<dt id="initializeBody"><a name="initializeBody,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">mass</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">moment</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a cpBody.

</dd>
<dt id="newBody"><a name="newBody,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">mass</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">moment</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a cpBody.

</dd>
<dt id="newKinematicBody"><a name="newKinematicBody,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newKinematicBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyNewKinematic&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a cpBody, and set it as a kinematic body.

</dd>
<dt id="newStaticBody"><a name="newStaticBody,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newStaticBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyNewStatic&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a cpBody, and set it as a static body.

</dd>
<dt id="finalize"><a name="finalize,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">finalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyDestroy&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy a cpBody.

</dd>
<dt id="destroy"><a name="destroy,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy and free a cpBody.

</dd>
<dt id="activate"><a name="activate,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">activate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyActivate&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Wake up a sleeping or idle body.

</dd>
<dt id="activateStatic"><a name="activateStatic,Body,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">activateStatic</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyActivateStatic&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Wake up any sleeping or idle bodies touching a static body.

</dd>
<dt id="sleep"><a name="sleep,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">sleep</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySleep&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Force a body to fall asleep immediately.

</dd>
<dt id="sleepWithGroup"><a name="sleepWithGroup,Body,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">sleepWithGroup</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">group</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySleepWithGroup&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Force a body to fall asleep immediately along with other bodies in a group.

</dd>
<dt id="isSleeping"><a name="isSleeping,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isSleeping</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyIsSleeping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Returns true if the body is sleeping.

</dd>
<dt id="bodyType"><a name="bodyType,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bodyType</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BodyType</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetType&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the type of the body.

</dd>
<dt id="="><a name="=,Body,BodyType"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">bodyType</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">type</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">BodyType</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetType&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the type of the body.

</dd>
<dt id="space"><a name="space,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">space</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetSpace&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the space this body is added to.

</dd>
<dt id="mass"><a name="mass,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mass</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetMass&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the mass of the body.

</dd>
<dt id="="><a name="=,Body,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">mass</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetMass&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the mass of the body.

</dd>
<dt id="moment"><a name="moment,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">moment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetMoment&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the moment of inertia of the body.

</dd>
<dt id="="><a name="=,Body,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">moment</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetMoment&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the moment of inertia of the body.

</dd>
<dt id="position"><a name="position,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">position</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetPosition&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the position of a body.

</dd>
<dt id="="><a name="=,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">position</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">pos</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetPosition&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the position of the body.

</dd>
<dt id="centerOfGravity"><a name="centerOfGravity,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">centerOfGravity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetCenterOfGravity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the offset of the center of gravity in body local coordinates.

</dd>
<dt id="="><a name="=,Body,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">centerOfGravity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">cog</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetCenterOfGravity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the offset of the center of gravity in body local coordinates.

</dd>
<dt id="velocity"><a name="velocity,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">velocity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the velocity of the body.

</dd>
<dt id="="><a name="=,Body,Vect_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">velocity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">velocity</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the velocity of the body.

</dd>
<dt id="force"><a name="force,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">force</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetForce&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the force applied to the body for the next time step.

</dd>
<dt id="="><a name="=,Body,Vect_4"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">force</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">force</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetForce&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the force applied to the body for the next time step.

</dd>
<dt id="angle"><a name="angle,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">angle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the angle of the body.

</dd>
<dt id="="><a name="=,Body,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">angle</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the angle of a body.

</dd>
<dt id="angularVelocity"><a name="angularVelocity,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">angularVelocity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetAngularVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the angular velocity of the body.

</dd>
<dt id="="><a name="=,Body,Float_4"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">angularVelocity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">angularVelocity</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetAngularVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the angular velocity of the body.

</dd>
<dt id="torque"><a name="torque,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">torque</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetTorque&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the torque applied to the body for the next time step.

</dd>
<dt id="="><a name="=,Body,Float_5"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">torque</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">torque</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetTorque&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the torque applied to the body for the next time step.

</dd>
<dt id="rotation"><a name="rotation,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">rotation</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetRotation&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the rotation vector of the body. (The x basis vector of it's transform.)

</dd>
<dt id="userData"><a name="userData,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DataPointer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the user data pointer assigned to the body.

</dd>
<dt id="="><a name="=,Body,DataPointer"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">userData</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the user data pointer assigned to the body.

</dd>
<dt id="="><a name="=,Body,BodyVelocityFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">velocityUpdateFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">velocityFunc</span><span class="Other">:</span> <span class="Identifier">BodyVelocityFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetVelocityUpdateFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the callback used to update a body's velocity.

</dd>
<dt id="="><a name="=,Body,BodyPositionFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">positionUpdateFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">positionFunc</span><span class="Other">:</span> <span class="Identifier">BodyPositionFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodySetPositionUpdateFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the callback used to update a body's position. NOTE: It's not generally recommended to override this unless you call the default position update function.

</dd>
<dt id="updateVelocity"><a name="updateVelocity,Body,Vect,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">updateVelocity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">gravity</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">dt</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyUpdateVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Default velocity integration function..

</dd>
<dt id="updatePosition"><a name="updatePosition,Body,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">updatePosition</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">dt</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyUpdatePosition&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Default position integration function.

</dd>
<dt id="localToWorld"><a name="localToWorld,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">localToWorld</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyLocalToWorld&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convert body relative/local coordinates to absolute/world coordinates.

</dd>
<dt id="worldToLocal"><a name="worldToLocal,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">worldToLocal</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyWorldToLocal&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convert body absolute/world coordinates to  relative/local coordinates.

</dd>
<dt id="applyForceAtWorldPoint"><a name="applyForceAtWorldPoint,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">applyForceAtWorldPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">force</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyApplyForceAtWorldPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Apply a force to a body. Both the force and point are expressed in world coordinates.

</dd>
<dt id="applyForceAtLocalPoint"><a name="applyForceAtLocalPoint,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">applyForceAtLocalPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">force</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyApplyForceAtLocalPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Apply a force to a body. Both the force and point are expressed in body local coordinates.

</dd>
<dt id="applyImpulseAtWorldPoint"><a name="applyImpulseAtWorldPoint,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">applyImpulseAtWorldPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">impulse</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyApplyImpulseAtWorldPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Apply an impulse to a body. Both the impulse and point are expressed in world coordinates.

</dd>
<dt id="applyImpulseAtLocalPoint"><a name="applyImpulseAtLocalPoint,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">applyImpulseAtLocalPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">impulse</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyApplyImpulseAtLocalPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates.

</dd>
<dt id="velocityAtWorldPoint"><a name="velocityAtWorldPoint,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">velocityAtWorldPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetVelocityAtWorldPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the velocity on a body (in world units) at a point on the body in world coordinates.

</dd>
<dt id="velocityAtLocalPoint"><a name="velocityAtLocalPoint,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">velocityAtLocalPoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyGetVelocityAtLocalPoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the velocity on a body (in world units) at a point on the body in local coordinates.

</dd>
<dt id="kineticEnergy"><a name="kineticEnergy,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">kineticEnergy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyKineticEnergy&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the amount of kinetic energy contained by the body.

</dd>
<dt id="eachShape"><a name="eachShape,Body,BodyShapeIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">BodyShapeIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyEachShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> once for each shape attached to <cite>body</cite> and added to the space.

</dd>
<dt id="eachConstraint"><a name="eachConstraint,Body,BodyConstraintIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachConstraint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">BodyConstraintIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyEachConstraint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> once for each constraint attached to <cite>body</cite> and added to the space.

</dd>
<dt id="eachArbiter"><a name="eachArbiter,Body,BodyArbiterIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachArbiter</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">BodyArbiterIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBodyEachArbiter&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> once for each arbiter that is currently active on the body.

</dd>
<dt id="newShapeFilter"><a name="newShapeFilter,Group,Bitmask,Bitmask"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newShapeFilter</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">group</span><span class="Other">:</span> <span class="Identifier">Group</span><span class="Other">;</span> <span class="Identifier">categories</span><span class="Other">:</span> <span class="Identifier">Bitmask</span><span class="Other">;</span> <span class="Identifier">mask</span><span class="Other">:</span> <span class="Identifier">Bitmask</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Create a new collision filter.

</dd>
<dt id="finalize"><a name="finalize,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">finalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeDestroy&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy a shape.

</dd>
<dt id="destroy"><a name="destroy,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy and Free a shape.

</dd>
<dt id="destroy"><a name="destroy,PolyShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,SegmentShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,CircleShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">CircleShape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="cacheBB"><a name="cacheBB,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">cacheBB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeCacheBB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Update, cache and return the bounding box of a shape based on the body it's attached to.

</dd>
<dt id="update"><a name="update,Shape,Transform"></a><pre><span class="Keyword">proc</span> <span class="Identifier">update</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">transform</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeUpdate&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Update, cache and return the bounding box of a shape with an explicit transformation.

</dd>
<dt id="pointQuery"><a name="pointQuery,Shape,Vect,ptr.PointQueryInfo"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pointQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">p</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">out</span><span class="Other">`</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">PointQueryInfo</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapePointQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a nearest point query. It finds the closest point on the surface of shape to a specific point. The value returned is the distance between the points. A negative distance means the point is inside the shape.

</dd>
<dt id="segmentQuery"><a name="segmentQuery,Shape,Vect,Vect,Float,ptr.SegmentQueryInfo"></a><pre><span class="Keyword">proc</span> <span class="Identifier">segmentQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                  <span class="Identifier">info</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">SegmentQueryInfo</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSegmentQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a segment query against a shape. <cite>info</cite> must be a pointer to a valid cpSegmentQueryInfo structure.

</dd>
<dt id="collide"><a name="collide,Shape,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collide</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ContactPointSet</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapesCollide&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Return contact information about two shapes.

</dd>
<dt id="space"><a name="space,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">space</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetSpace&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
The cpSpace this body is added to.

</dd>
<dt id="body"><a name="body,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">body</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
The cpBody this shape is connected to.

</dd>
<dt id="="><a name="=,Shape,Body"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">body</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the cpBody this shape is connected to. Can only be used if the shape is not currently added to a space.

</dd>
<dt id="mass"><a name="mass,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mass</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetMass&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the mass of the shape if you are having Chipmunk calculate mass properties for you.

</dd>
<dt id="="><a name="=,Shape,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">mass</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">mass</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetMass&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the mass of this shape to have Chipmunk calculate mass properties for you.

</dd>
<dt id="density"><a name="density,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">density</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetDensity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the density of the shape if you are having Chipmunk calculate mass properties for you.

</dd>
<dt id="="><a name="=,Shape,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">density</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">density</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetDensity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the density  of this shape to have Chipmunk calculate mass properties for you.

</dd>
<dt id="moment"><a name="moment,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">moment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetMoment&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the calculated moment of inertia for this shape.

</dd>
<dt id="area"><a name="area,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">area</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetArea&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the calculated area of this shape.

</dd>
<dt id="centerOfGravity"><a name="centerOfGravity,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">centerOfGravity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
                                        <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetCenterOfGravity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the centroid of this shape.

</dd>
<dt id="bB"><a name="bB,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">BB</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetBB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the bounding box that contains the shape given it's current position and angle.

</dd>
<dt id="sensor"><a name="sensor,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">sensor</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetSensor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get if the shape is set to be a sensor or not.

</dd>
<dt id="="><a name="=,Shape,bool"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">sensor</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">sensor</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetSensor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set if the shape is a sensor or not.

</dd>
<dt id="elasticity"><a name="elasticity,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">elasticity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetElasticity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the elasticity of this shape.

</dd>
<dt id="="><a name="=,Shape,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">elasticity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">elasticity</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetElasticity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the elasticity of this shape.

</dd>
<dt id="friction"><a name="friction,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">friction</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetFriction&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the friction of this shape.

</dd>
<dt id="="><a name="=,Shape,Float_4"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">friction</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">friction</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetFriction&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the friction of this shape.

</dd>
<dt id="surfaceVelocity"><a name="surfaceVelocity,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">surfaceVelocity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
                                        <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetSurfaceVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the surface velocity of this shape.

</dd>
<dt id="="><a name="=,Shape,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">surfaceVelocity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">surfaceVelocity</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetSurfaceVelocity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the surface velocity of this shape.

</dd>
<dt id="userData"><a name="userData,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DataPointer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the user definable data pointer of this shape.

</dd>
<dt id="="><a name="=,Shape,DataPointer"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">userData</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the user definable data pointer of this shape.

</dd>
<dt id="collisionType"><a name="collisionType,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collisionType</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CollisionType</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetCollisionType&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the collision type of this shape.

</dd>
<dt id="="><a name="=,Shape,CollisionType"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">collisionType</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">collisionType</span><span class="Other">:</span> <span class="Identifier">CollisionType</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetCollisionType&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the collision type of this shape.

</dd>
<dt id="filter"><a name="filter,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">filter</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeGetFilter&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the collision filtering parameters of this shape.

</dd>
<dt id="="><a name="=,Shape,ShapeFilter"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">filter</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpShapeSetFilter&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the collision filtering parameters of this shape.

</dd>
<dt id="allocateCircleShape"><a name="allocateCircleShape,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateCircleShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CircleShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCircleShapeAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a circle shape.

</dd>
<dt id="initializeCircleShape"><a name="initializeCircleShape,CircleShape,Body,Float,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeCircleShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">circle</span><span class="Other">:</span> <span class="Identifier">CircleShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                           <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CircleShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCircleShapeInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a circle shape.

</dd>
<dt id="newCircleShape"><a name="newCircleShape,Body,Float,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newCircleShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CircleShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCircleShapeNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a circle shape.

</dd>
<dt id="offset"><a name="offset,CircleShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">offset</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">CircleShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCircleShapeGetOffset&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the offset of a circle shape.

</dd>
<dt id="radius"><a name="radius,CircleShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">radius</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">CircleShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCircleShapeGetRadius&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the radius of a circle shape.

</dd>
<dt id="allocateSegmentShape"><a name="allocateSegmentShape,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSegmentShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a segment shape.

</dd>
<dt id="initializeSegmentShape"><a name="initializeSegmentShape,SegmentShape,Body,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSegmentShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">seg</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                            <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a segment shape.

</dd>
<dt id="newSegmentShape"><a name="newSegmentShape,Body,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSegmentShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a segment shape.

</dd>
<dt id="="><a name="=,SegmentShape,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">neighbors</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">;</span> <span class="Identifier">prev</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">next</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeSetNeighbors&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Let Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps.

</dd>
<dt id="a"><a name="a,SegmentShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeGetA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the first endpoint of a segment shape.

</dd>
<dt id="b"><a name="b,SegmentShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeGetB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the second endpoint of a segment shape.

</dd>
<dt id="normal"><a name="normal,SegmentShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">normal</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeGetNormal&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the normal of a segment shape.

</dd>
<dt id="radius"><a name="radius,SegmentShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">radius</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">SegmentShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSegmentShapeGetRadius&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the first endpoint of a segment shape.

</dd>
<dt id="allocatePolyShape"><a name="allocatePolyShape,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocatePolyShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a polygon shape.

</dd>
<dt id="initializePolyShape"><a name="initializePolyShape,PolyShape,Body,cint,ptr.Vect,Transform,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializePolyShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">poly</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                         <span class="Identifier">transform</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a polygon shape with rounded corners. A convex hull will be created from the vertexes.

</dd>
<dt id="initializePolyShape"><a name="initializePolyShape,PolyShape,Body,cint,ptr.Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializePolyShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">poly</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                         <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeInitRaw&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a polygon shape with rounded corners. The vertexes must be convex with a counter-clockwise winding.

</dd>
<dt id="newPolyShape"><a name="newPolyShape,Body,cint,ptr.Vect,Transform,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newPolyShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">transform</span><span class="Other">:</span> <span class="Identifier">Transform</span><span class="Other">;</span>
                  <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a polygon shape with rounded corners. A convex hull will be created from the vertexes.

</dd>
<dt id="newPolyShape"><a name="newPolyShape,Body,cint,ptr.Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newPolyShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeNewRaw&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a polygon shape with rounded corners. The vertexes must be convex with a counter-clockwise winding.

</dd>
<dt id="initializeBoxShape"><a name="initializeBoxShape,PolyShape,Body,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeBoxShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">poly</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                        <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBoxShapeInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a box shaped polygon shape with rounded corners.

</dd>
<dt id="initializeBoxShape"><a name="initializeBoxShape,PolyShape,Body,BB,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeBoxShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">poly</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">box</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBoxShapeInit2&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize an offset box shaped polygon shape with rounded corners.

</dd>
<dt id="newBoxShape"><a name="newBoxShape,Body,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newBoxShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBoxShapeNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a box shaped polygon shape.

</dd>
<dt id="newBoxShape"><a name="newBoxShape,Body,BB,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newBoxShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">box</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PolyShape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpBoxShapeNew2&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize an offset box shaped polygon shape.

</dd>
<dt id="count"><a name="count,PolyShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">count</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeGetCount&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the number of verts in a polygon shape.

</dd>
<dt id="vert"><a name="vert,PolyShape,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">vert</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">;</span> <span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeGetVert&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the <cite>ith</cite> vertex of a polygon shape.

</dd>
<dt id="radius"><a name="radius,PolyShape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">radius</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">PolyShape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPolyShapeGetRadius&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the radius of a polygon shape.

</dd>
<dt id="finalize"><a name="finalize,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">finalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintDestroy&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy a constraint.

</dd>
<dt id="destroy"><a name="destroy,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy and free a constraint.

</dd>
<dt id="destroy"><a name="destroy,PinJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,RotaryLimitJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,SlideJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,GearJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,DampedRotarySpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,GrooveJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,RatchetJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,SimpleMotor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="destroy"><a name="destroy,PivotJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="space"><a name="space,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">space</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetSpace&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the cpSpace this constraint is added to.

</dd>
<dt id="bodyA"><a name="bodyA,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bodyA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetBodyA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the first body the constraint is attached to.

</dd>
<dt id="bodyB"><a name="bodyB,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bodyB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetBodyB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the second body the constraint is attached to.

</dd>
<dt id="maxForce"><a name="maxForce,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">maxForce</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetMaxForce&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the maximum force that this constraint is allowed to use.

</dd>
<dt id="="><a name="=,Constraint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">maxForce</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">maxForce</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetMaxForce&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the maximum force that this constraint is allowed to use. (defaults to INFINITY)

</dd>
<dt id="errorBias"><a name="errorBias,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">errorBias</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetErrorBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get rate at which joint error is corrected.

</dd>
<dt id="="><a name="=,Constraint,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">errorBias</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">errorBias</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetErrorBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set rate at which joint error is corrected. Defaults to pow(1.0 - 0.1, 60.0) meaning that it will correct 10% of the error every 1/60th of a second.

</dd>
<dt id="maxBias"><a name="maxBias,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">maxBias</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetMaxBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the maximum rate at which joint error is corrected.

</dd>
<dt id="="><a name="=,Constraint,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">maxBias</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">maxBias</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetMaxBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the maximum rate at which joint error is corrected. (defaults to INFINITY)

</dd>
<dt id="collideBodies"><a name="collideBodies,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collideBodies</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetCollideBodies&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get if the two bodies connected by the constraint are allowed to collide or not.

</dd>
<dt id="="><a name="=,Constraint,bool"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">collideBodies</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">collideBodies</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetCollideBodies&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set if the two bodies connected by the constraint are allowed to collide or not. (defaults to cpFalse)

</dd>
<dt id="preSolveFunc"><a name="preSolveFunc,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">preSolveFunc</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ConstraintPreSolveFunc</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetPreSolveFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the pre-solve function that is called before the solver runs.

</dd>
<dt id="="><a name="=,Constraint,ConstraintPreSolveFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">preSolveFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">preSolveFunc</span><span class="Other">:</span> <span class="Identifier">ConstraintPreSolveFunc</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetPreSolveFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the pre-solve function that is called before the solver runs.

</dd>
<dt id="postSolveFunc"><a name="postSolveFunc,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">postSolveFunc</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">ConstraintPostSolveFunc</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetPostSolveFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the post-solve function that is called before the solver runs.

</dd>
<dt id="="><a name="=,Constraint,ConstraintPostSolveFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">postSolveFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span>
                      <span class="Identifier">postSolveFunc</span><span class="Other">:</span> <span class="Identifier">ConstraintPostSolveFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetPostSolveFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the post-solve function that is called before the solver runs.

</dd>
<dt id="userData"><a name="userData,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DataPointer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the user definable data pointer for this constraint

</dd>
<dt id="="><a name="=,Constraint,DataPointer"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">userData</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintSetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the user definable data pointer for this constraint

</dd>
<dt id="impulse"><a name="impulse,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">impulse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintGetImpulse&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the last impulse applied by this constraint.

</dd>
<dt id="isPinJoint"><a name="isPinJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isPinJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsPinJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a pin joint.

</dd>
<dt id="allocatePinJoint"><a name="allocatePinJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocatePinJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PinJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a pin joint.

</dd>
<dt id="initializePinJoint"><a name="initializePinJoint,PinJoint,Body,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializePinJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PinJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a pin joint.

</dd>
<dt id="newPinJoint"><a name="newPinJoint,Body,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newPinJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PinJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a pin joint.

</dd>
<dt id="anchorA"><a name="anchorA,PinJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointGetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the first anchor relative to the first body.

</dd>
<dt id="="><a name="=,PinJoint,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorA</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointSetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the first anchor relative to the first body.

</dd>
<dt id="anchorB"><a name="anchorB,PinJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointGetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the second anchor relative to the second body.

</dd>
<dt id="="><a name="=,PinJoint,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointSetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the second anchor relative to the second body.

</dd>
<dt id="dist"><a name="dist,PinJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">dist</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointGetDist&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the distance the joint will maintain between the two anchors.

</dd>
<dt id="="><a name="=,PinJoint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">dist</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PinJoint</span><span class="Other">;</span> <span class="Identifier">dist</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPinJointSetDist&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the distance the joint will maintain between the two anchors.

</dd>
<dt id="isSlideJoint"><a name="isSlideJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isSlideJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsSlideJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a slide joint.

</dd>
<dt id="allocateSlideJoint"><a name="allocateSlideJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSlideJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a slide joint.

</dd>
<dt id="initializeSlideJoint"><a name="initializeSlideJoint,SlideJoint,Body,Body,Vect,Vect,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSlideJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                          <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a slide joint.

</dd>
<dt id="newSlideJoint"><a name="newSlideJoint,Body,Body,Vect,Vect,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSlideJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a slide joint.

</dd>
<dt id="anchorA"><a name="anchorA,SlideJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointGetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the first anchor relative to the first body.

</dd>
<dt id="="><a name="=,SlideJoint,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorA</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointSetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the first anchor relative to the first body.

</dd>
<dt id="anchorB"><a name="anchorB,SlideJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointGetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the second anchor relative to the second body.

</dd>
<dt id="="><a name="=,SlideJoint,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointSetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the second anchor relative to the second body.

</dd>
<dt id="min"><a name="min,SlideJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">min</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointGetMin&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the minimum distance the joint will maintain between the two anchors.

</dd>
<dt id="="><a name="=,SlideJoint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">min</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointSetMin&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the minimum distance the joint will maintain between the two anchors.

</dd>
<dt id="max"><a name="max,SlideJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">max</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointGetMax&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the maximum distance the joint will maintain between the two anchors.

</dd>
<dt id="="><a name="=,SlideJoint,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">max</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SlideJoint</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSlideJointSetMax&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the maximum distance the joint will maintain between the two anchors.

</dd>
<dt id="isPivotJoint"><a name="isPivotJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isPivotJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsPivotJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a pivot joint.

</dd>
<dt id="allocatePivotJoint"><a name="allocatePivotJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocatePivotJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a pivot joint

</dd>
<dt id="initializePivotJoint"><a name="initializePivotJoint,PivotJoint,Body,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializePivotJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                          <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a pivot joint.

</dd>
<dt id="newPivotJoint"><a name="newPivotJoint,Body,Body,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newPivotJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">pivot</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a pivot joint.

</dd>
<dt id="newPivotJoint"><a name="newPivotJoint,Body,Body,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newPivotJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointNew2&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a pivot joint with specific anchors.

</dd>
<dt id="anchorA"><a name="anchorA,PivotJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointGetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the first anchor relative to the first body.

</dd>
<dt id="="><a name="=,PivotJoint,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorA</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointSetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the first anchor relative to the first body.

</dd>
<dt id="anchorB"><a name="anchorB,PivotJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointGetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the second anchor relative to the second body.

</dd>
<dt id="="><a name="=,PivotJoint,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">PivotJoint</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpPivotJointSetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the second anchor relative to the second body.

</dd>
<dt id="isGrooveJoint"><a name="isGrooveJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isGrooveJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsGrooveJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a slide joint.

</dd>
<dt id="allocateGrooveJoint"><a name="allocateGrooveJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateGrooveJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a groove joint.

</dd>
<dt id="initializeGrooveJoint"><a name="initializeGrooveJoint,GrooveJoint,Body,Body,Vect,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeGrooveJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">groove_a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                           <span class="Identifier">groove_b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a groove joint.

</dd>
<dt id="newGrooveJoint"><a name="newGrooveJoint,Body,Body,Vect,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newGrooveJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">groove_a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">groove_b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a groove joint.

</dd>
<dt id="grooveA"><a name="grooveA,GrooveJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">grooveA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointGetGrooveA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the first endpoint of the groove relative to the first body.

</dd>
<dt id="="><a name="=,GrooveJoint,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">grooveA</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">;</span> <span class="Identifier">grooveA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointSetGrooveA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the first endpoint of the groove relative to the first body.

</dd>
<dt id="grooveB"><a name="grooveB,GrooveJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">grooveB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointGetGrooveB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the first endpoint of the groove relative to the first body.

</dd>
<dt id="="><a name="=,GrooveJoint,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">grooveB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">;</span> <span class="Identifier">grooveB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointSetGrooveB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the first endpoint of the groove relative to the first body.

</dd>
<dt id="anchorB"><a name="anchorB,GrooveJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointGetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the second anchor relative to the second body.

</dd>
<dt id="="><a name="=,GrooveJoint,Vect_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GrooveJoint</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGrooveJointSetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the second anchor relative to the second body.

</dd>
<dt id="isDampedSpring"><a name="isDampedSpring,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isDampedSpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsDampedSpring&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a slide joint.

</dd>
<dt id="allocateDampedSpring"><a name="allocateDampedSpring,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateDampedSpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a damped spring.

</dd>
<dt id="initializeDampedSpring"><a name="initializeDampedSpring,DampedSpring,Body,Body,Vect,Vect,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeDampedSpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span>
                            <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">restLength</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                            <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a damped spring.

</dd>
<dt id="newDampedSpring"><a name="newDampedSpring,Body,Body,Vect,Vect,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newDampedSpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">restLength</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                     <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a damped spring.

</dd>
<dt id="anchorA"><a name="anchorA,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorA</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the first anchor relative to the first body.

</dd>
<dt id="="><a name="=,DampedSpring,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorA</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">anchorA</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetAnchorA&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the first anchor relative to the first body.

</dd>
<dt id="anchorB"><a name="anchorB,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">anchorB</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the location of the second anchor relative to the second body.

</dd>
<dt id="="><a name="=,DampedSpring,Vect_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">anchorB</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">anchorB</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetAnchorB&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the location of the second anchor relative to the second body.

</dd>
<dt id="restLength"><a name="restLength,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">restLength</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetRestLength&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the rest length of the spring.

</dd>
<dt id="="><a name="=,DampedSpring,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">restLength</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">restLength</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetRestLength&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the rest length of the spring.

</dd>
<dt id="stiffness"><a name="stiffness,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">stiffness</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetStiffness&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the stiffness of the spring in force/distance.

</dd>
<dt id="="><a name="=,DampedSpring,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">stiffness</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetStiffness&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the stiffness of the spring in force/distance.

</dd>
<dt id="damping"><a name="damping,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">damping</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the damping of the spring.

</dd>
<dt id="="><a name="=,DampedSpring,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">damping</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the damping of the spring.

</dd>
<dt id="springForceFunc"><a name="springForceFunc,DampedSpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">springForceFunc</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedSpringForceFunc</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringGetSpringForceFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the damping of the spring.

</dd>
<dt id="="><a name="=,DampedSpring,DampedSpringForceFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">springForceFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedSpring</span><span class="Other">;</span>
                        <span class="Identifier">springForceFunc</span><span class="Other">:</span> <span class="Identifier">DampedSpringForceFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedSpringSetSpringForceFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the damping of the spring.

</dd>
<dt id="isDampedRotarySpring"><a name="isDampedRotarySpring,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isDampedRotarySpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsDampedRotarySpring&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a damped rotary springs.

</dd>
<dt id="allocateDampedRotarySpring"><a name="allocateDampedRotarySpring,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateDampedRotarySpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a damped rotary spring.

</dd>
<dt id="initializeDampedRotarySpring"><a name="initializeDampedRotarySpring,DampedRotarySpring,Body,Body,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeDampedRotarySpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span>
                                  <span class="Identifier">restAngle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a damped rotary spring.

</dd>
<dt id="newDampedRotarySpring"><a name="newDampedRotarySpring,Body,Body,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newDampedRotarySpring</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">restAngle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                           <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a damped rotary spring.

</dd>
<dt id="restAngle"><a name="restAngle,DampedRotarySpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">restAngle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringGetRestAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the rest length of the spring.

</dd>
<dt id="="><a name="=,DampedRotarySpring,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">restAngle</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">;</span> <span class="Identifier">restAngle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringSetRestAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the rest length of the spring.

</dd>
<dt id="stiffness"><a name="stiffness,DampedRotarySpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">stiffness</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringGetStiffness&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the stiffness of the spring in force/distance.

</dd>
<dt id="="><a name="=,DampedRotarySpring,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">stiffness</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">;</span> <span class="Identifier">stiffness</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringSetStiffness&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the stiffness of the spring in force/distance.

</dd>
<dt id="damping"><a name="damping,DampedRotarySpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">damping</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringGetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the damping of the spring.

</dd>
<dt id="="><a name="=,DampedRotarySpring,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">damping</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringSetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the damping of the spring.

</dd>
<dt id="springTorqueFunc"><a name="springTorqueFunc,DampedRotarySpring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">springTorqueFunc</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpringTorqueFunc</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringGetSpringTorqueFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the damping of the spring.

</dd>
<dt id="="><a name="=,DampedRotarySpring,DampedRotarySpringTorqueFunc"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">springTorqueFunc</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpring</span><span class="Other">;</span>
                         <span class="Identifier">springTorqueFunc</span><span class="Other">:</span> <span class="Identifier">DampedRotarySpringTorqueFunc</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpDampedRotarySpringSetSpringTorqueFunc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the damping of the spring.

</dd>
<dt id="isRotaryLimitJoint"><a name="isRotaryLimitJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isRotaryLimitJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsRotaryLimitJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a damped rotary springs.

</dd>
<dt id="allocateRotaryLimitJoint"><a name="allocateRotaryLimitJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateRotaryLimitJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a damped rotary limit joint.

</dd>
<dt id="initializeRotaryLimitJoint"><a name="initializeRotaryLimitJoint,RotaryLimitJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeRotaryLimitJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                                <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a damped rotary limit joint.

</dd>
<dt id="newRotaryLimitJoint"><a name="newRotaryLimitJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newRotaryLimitJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a damped rotary limit joint.

</dd>
<dt id="min"><a name="min,RotaryLimitJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">min</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointGetMin&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the minimum distance the joint will maintain between the two anchors.

</dd>
<dt id="="><a name="=,RotaryLimitJoint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">min</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">;</span> <span class="Identifier">min</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointSetMin&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the minimum distance the joint will maintain between the two anchors.

</dd>
<dt id="max"><a name="max,RotaryLimitJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">max</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointGetMax&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the maximum distance the joint will maintain between the two anchors.

</dd>
<dt id="="><a name="=,RotaryLimitJoint,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">max</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RotaryLimitJoint</span><span class="Other">;</span> <span class="Identifier">max</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRotaryLimitJointSetMax&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the maximum distance the joint will maintain between the two anchors.

</dd>
<dt id="isRatchetJoint"><a name="isRatchetJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isRatchetJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsRatchetJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a damped rotary springs.

</dd>
<dt id="allocateRatchetJoint"><a name="allocateRatchetJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateRatchetJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a ratchet joint.

</dd>
<dt id="initializeRatchetJoint"><a name="initializeRatchetJoint,RatchetJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeRatchetJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                            <span class="Identifier">ratchet</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a ratched joint.

</dd>
<dt id="newRatchetJoint"><a name="newRatchetJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newRatchetJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">ratchet</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a ratchet joint.

</dd>
<dt id="angle"><a name="angle,RatchetJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">angle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointGetAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the angle of the current ratchet tooth.

</dd>
<dt id="="><a name="=,RatchetJoint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">angle</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">;</span> <span class="Identifier">angle</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointSetAngle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the angle of the current ratchet tooth.

</dd>
<dt id="phase"><a name="phase,RatchetJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">phase</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointGetPhase&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the phase offset of the ratchet.

</dd>
<dt id="="><a name="=,RatchetJoint,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">phase</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointSetPhase&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the phase offset of the ratchet.

</dd>
<dt id="ratchet"><a name="ratchet,RatchetJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">ratchet</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointGetRatchet&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the angular distance of each ratchet.

</dd>
<dt id="="><a name="=,RatchetJoint,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">ratchet</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">RatchetJoint</span><span class="Other">;</span> <span class="Identifier">ratchet</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpRatchetJointSetRatchet&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the angular distance of each ratchet.

</dd>
<dt id="isGearJoint"><a name="isGearJoint,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isGearJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsGearJoint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a damped rotary springs.

</dd>
<dt id="allocateGearJoint"><a name="allocateGearJoint,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateGearJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GearJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a gear joint.

</dd>
<dt id="initializeGearJoint"><a name="initializeGearJoint,GearJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeGearJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">ratio</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GearJoint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a gear joint.

</dd>
<dt id="newGearJoint"><a name="newGearJoint,Body,Body,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newGearJoint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">ratio</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">GearJoint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a gear joint.

</dd>
<dt id="phase"><a name="phase,GearJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">phase</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointGetPhase&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the phase offset of the gears.

</dd>
<dt id="="><a name="=,GearJoint,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">phase</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">;</span> <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointSetPhase&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the phase offset of the gears.

</dd>
<dt id="ratio"><a name="ratio,GearJoint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">ratio</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointGetRatio&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the angular distance of each ratchet.

</dd>
<dt id="="><a name="=,GearJoint,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">ratio</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">GearJoint</span><span class="Other">;</span> <span class="Identifier">ratio</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpGearJointSetRatio&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the ratio of a gear joint.

</dd>
<dt id="isSimpleMotor"><a name="isSimpleMotor,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isSimpleMotor</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConstraintIsSimpleMotor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Check if a constraint is a damped rotary springs.

</dd>
<dt id="allocateSimpleMotor"><a name="allocateSimpleMotor,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSimpleMotor</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSimpleMotorAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a simple motor.

</dd>
<dt id="initializeSimpleMotor"><a name="initializeSimpleMotor,SimpleMotor,Body,Body,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSimpleMotor</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">joint</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">rate</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSimpleMotorInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
initialize a simple motor.

</dd>
<dt id="newSimpleMotor"><a name="newSimpleMotor,Body,Body,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSimpleMotor</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">;</span> <span class="Identifier">rate</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSimpleMotorNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a simple motor.

</dd>
<dt id="rate"><a name="rate,SimpleMotor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">rate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSimpleMotorGetRate&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the rate of the motor.

</dd>
<dt id="="><a name="=,SimpleMotor,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">rate</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">SimpleMotor</span><span class="Other">;</span> <span class="Identifier">rate</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSimpleMotorSetRate&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the rate of the motor.

</dd>
<dt id="allocateSpace"><a name="allocateSpace,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">allocateSpace</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAlloc&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a cpSpace.

</dd>
<dt id="initializeSpace"><a name="initializeSpace,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">initializeSpace</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceInit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initialize a cpSpace.

</dd>
<dt id="newSpace"><a name="newSpace,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newSpace</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Space</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceNew&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate and initialize a cpSpace.

</dd>
<dt id="finalize"><a name="finalize,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">finalize</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceDestroy&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy a cpSpace.

</dd>
<dt id="destroy"><a name="destroy,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">destroy</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceFree&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Destroy and free a cpSpace.

</dd>
<dt id="iterations"><a name="iterations,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">iterations</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetIterations&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,cint"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">iterations</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">iterations</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetIterations&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Number of iterations to use in the impulse solver to solve contacts and other constraints.

</dd>
<dt id="gravity"><a name="gravity,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">gravity</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetGravity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">gravity</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">gravity</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetGravity&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gravity to pass to rigid bodies when integrating velocity.

</dd>
<dt id="damping"><a name="damping,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">damping</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">damping</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">damping</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetDamping&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Damping rate expressed as the fraction of velocity bodies retain each second. A value of 0.9 would mean that each body's velocity will drop 10% per second. The default value is 1.0, meaning no damping is applied. @note This damping value is different than those of cpDampedSpring and cpDampedRotarySpring.

</dd>
<dt id="idleSpeedThreshold"><a name="idleSpeedThreshold,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">idleSpeedThreshold</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetIdleSpeedThreshold&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Float_2"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">idleSpeedThreshold</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">idleSpeedThreshold</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetIdleSpeedThreshold&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Speed threshold for a body to be considered idle. The default value of 0 means to let the space guess a good threshold based on gravity.

</dd>
<dt id="sleepTimeThreshold"><a name="sleepTimeThreshold,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">sleepTimeThreshold</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetSleepTimeThreshold&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Float_3"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">sleepTimeThreshold</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">sleepTimeThreshold</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetSleepTimeThreshold&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Time a group of bodies must remain idle in order to fall asleep. Enabling sleeping also implicitly enables the the contact graph. The default value of INFINITY disables the sleeping algorithm.

</dd>
<dt id="collisionSlop"><a name="collisionSlop,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collisionSlop</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetCollisionSlop&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Float_4"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">collisionSlop</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">collisionSlop</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetCollisionSlop&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Amount of encouraged penetration between colliding shapes. Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap.

</dd>
<dt id="collisionBias"><a name="collisionBias,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collisionBias</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetCollisionBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Float_5"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">collisionBias</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">collisionBias</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetCollisionBias&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determines how fast overlapping shapes are pushed apart. Expressed as a fraction of the error remaining after each second. Defaults to pow(1.0 - 0.1, 60.0) meaning that Chipmunk fixes 10% of overlap each frame at 60Hz.

</dd>
<dt id="collisionPersistence"><a name="collisionPersistence,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">collisionPersistence</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Timestamp</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetCollisionPersistence&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,Timestamp"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">collisionPersistence</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">collisionPersistence</span><span class="Other">:</span> <span class="Identifier">Timestamp</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetCollisionPersistence&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Number of frames that contact information should persist. Defaults to 3. There is probably never a reason to change this value.

</dd>
<dt id="userData"><a name="userData,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">DataPointer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>


</dd>
<dt id="="><a name="=,Space,DataPointer"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Identifier">userData</span> <span class="Operator">=</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">DataPointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSetUserData&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
User definable data pointer. Generally this points to your game's controller or game state class so you can access it when given a cpSpace reference in a callback.

</dd>
<dt id="staticBody"><a name="staticBody,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">staticBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetStaticBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
The Space provided static body for a given cpSpace. This is merely provided for convenience and you are not required to use it.

</dd>
<dt id="currentTimeStep"><a name="currentTimeStep,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">currentTimeStep</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceGetCurrentTimeStep&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the current (or most recent) time step used with the given space. Useful from callbacks if your time step is not a compile-time global.

</dd>
<dt id="isLocked"><a name="isLocked,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">isLocked</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceIsLocked&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
returns true from inside a callback when objects cannot be added/removed.

</dd>
<dt id="addDefaultCollisionHandler"><a name="addDefaultCollisionHandler,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addDefaultCollisionHandler</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CollisionHandler</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddDefaultCollisionHandler&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Create or return the existing collision handler that is called for all collisions that are not handled by a more specific collision handler.

</dd>
<dt id="addCollisionHandler"><a name="addCollisionHandler,Space,CollisionType,CollisionType"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addCollisionHandler</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">CollisionType</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">CollisionType</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CollisionHandler</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddCollisionHandler&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Create or return the existing collision handler for the specified pair of collision types. If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers.

</dd>
<dt id="addWildcardHandler"><a name="addWildcardHandler,Space,CollisionType"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addWildcardHandler</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">type</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">CollisionType</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CollisionHandler</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddWildcardHandler&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Create or return the existing wildcard collision handler for the specified type.

</dd>
<dt id="addShape"><a name="addShape,Space,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Shape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Add a collision shape to the simulation. If the shape is attached to a static body, it will be added as a static shape.

</dd>
<dt id="addBody"><a name="addBody,Space,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Body</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Add a rigid body to the simulation.

</dd>
<dt id="addConstraint"><a name="addConstraint,Space,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addConstraint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Constraint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddConstraint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Add a constraint to the simulation.

</dd>
<dt id="removeShape"><a name="removeShape,Space,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">removeShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceRemoveShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Remove a collision shape from the simulation.

</dd>
<dt id="removeBody"><a name="removeBody,Space,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">removeBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceRemoveBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Remove a rigid body from the simulation.

</dd>
<dt id="removeConstraint"><a name="removeConstraint,Space,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">removeConstraint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceRemoveConstraint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Remove a constraint from the simulation.

</dd>
<dt id="containsShape"><a name="containsShape,Space,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">containsShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceContainsShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Test if a collision shape has been added to the space.

</dd>
<dt id="containsBody"><a name="containsBody,Space,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">containsBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceContainsBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Test if a rigid body has been added to the space.

</dd>
<dt id="containsConstraint"><a name="containsConstraint,Space,Constraint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">containsConstraint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">constraint</span><span class="Other">:</span> <span class="Identifier">Constraint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceContainsConstraint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Test if a constraint has been added to the space.

</dd>
<dt id="addPostStepCallback"><a name="addPostStepCallback,Space,PostStepFunc,pointer,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">addPostStepCallback</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">PostStepFunc</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                         <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceAddPostStepCallback&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Schedule a post-step callback to be called when cpSpaceStep() finishes. You can only register one callback per unique value for <cite>key</cite>. Returns true only if <cite>key</cite> has never been scheduled before. It's possible to pass <cite>NULL</cite> for <cite>func</cite> if you only want to mark <cite>key</cite> as being used.

</dd>
<dt id="pointQuery"><a name="pointQuery,Space,Vect,Float,ShapeFilter,SpacePointQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pointQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">maxDistance</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">;</span>
                <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpacePointQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpacePointQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Query the space at a point and call <cite>func</cite> for each shape found.

</dd>
<dt id="pointQueryNearest"><a name="pointQueryNearest,Space,Vect,Float,ShapeFilter,ptr.PointQueryInfo"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pointQueryNearest</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">point</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">maxDistance</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                       <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">out</span><span class="Other">`</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">PointQueryInfo</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Shape</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpacePointQueryNearest&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Query the space at a point and return the nearest shape found. Returns NULL if no shapes were found.

</dd>
<dt id="segmentQuery"><a name="segmentQuery,Space,Vect,Vect,Float,ShapeFilter,SpaceSegmentQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">segmentQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">start</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">end</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                  <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceSegmentQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSegmentQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a directed line segment query (like a raycast) against the space calling <cite>func</cite> for each shape intersected.

</dd>
<dt id="segmentQueryFirst"><a name="segmentQueryFirst,Space,Vect,Vect,Float,ShapeFilter,ptr.SegmentQueryInfo"></a><pre><span class="Keyword">proc</span> <span class="Identifier">segmentQueryFirst</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">start</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">end</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span>
                       <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">out</span><span class="Other">`</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">SegmentQueryInfo</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Shape</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceSegmentQueryFirst&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns NULL if no shapes were hit.

</dd>
<dt id="bBQuery"><a name="bBQuery,Space,BB,ShapeFilter,SpaceBBQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">bBQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">bb</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">;</span> <span class="Identifier">filter</span><span class="Other">:</span> <span class="Identifier">ShapeFilter</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceBBQueryFunc</span><span class="Other">;</span>
             <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceBBQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a fast rectangle query on the space calling <cite>func</cite> for each shape found. Only the shape's bounding boxes are checked for overlap, not their full shape.

</dd>
<dt id="shapeQuery"><a name="shapeQuery,Space,Shape,SpaceShapeQueryFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">shapeQuery</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceShapeQueryFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceShapeQuery&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Query a space for any shapes overlapping the given shape and call <cite>func</cite> for each shape found.

</dd>
<dt id="eachBody"><a name="eachBody,Space,SpaceBodyIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceBodyIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceEachBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> for each body in the space.

</dd>
<dt id="eachShape"><a name="eachShape,Space,SpaceShapeIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceShapeIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceEachShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> for each shape in the space.

</dd>
<dt id="eachConstraint"><a name="eachConstraint,Space,SpaceConstraintIteratorFunc,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">eachConstraint</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Other">`</span><span class="Keyword">func</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">SpaceConstraintIteratorFunc</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceEachConstraint&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Call <cite>func</cite> for each shape in the space.

</dd>
<dt id="reindexStatic"><a name="reindexStatic,Space"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindexStatic</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceReindexStatic&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Update the collision detection info for the static shapes in the space.

</dd>
<dt id="reindexShape"><a name="reindexShape,Space,Shape"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindexShape</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">shape</span><span class="Other">:</span> <span class="Identifier">Shape</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceReindexShape&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Update the collision detection data for a specific shape in the space.

</dd>
<dt id="reindexShapesForBody"><a name="reindexShapesForBody,Space,Body"></a><pre><span class="Keyword">proc</span> <span class="Identifier">reindexShapesForBody</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">Body</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceReindexShapesForBody&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Update the collision detection data for all shapes attached to a body.

</dd>
<dt id="useSpatialHash"><a name="useSpatialHash,Space,Float,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">useSpatialHash</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">dim</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceUseSpatialHash&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Switch the space to use a spatial has as it's spatial index.

</dd>
<dt id="step"><a name="step,Space,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">step</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">dt</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceStep&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Step the space forward in time by <cite>dt</cite>.

</dd>
<dt id="debugDraw"><a name="debugDraw,Space,ptr.SpaceDebugDrawOptions"></a><pre><span class="Keyword">proc</span> <span class="Identifier">debugDraw</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">space</span><span class="Other">:</span> <span class="Identifier">Space</span><span class="Other">;</span> <span class="Identifier">options</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">SpaceDebugDrawOptions</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpSpaceDebugDraw&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Debug draw the current state of the space using the supplied drawing options.

</dd>
<dt id="momentForCircle"><a name="momentForCircle,Float,Float,Float,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">momentForCircle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">r1</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">r2</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMomentForCircle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the moment of inertia for a circle. <cite>r1</cite> and <cite>r2</cite> are the inner and outer diameters. A solid circle has an inner diameter of 0.

</dd>
<dt id="areaForCircle"><a name="areaForCircle,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">areaForCircle</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">r1</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">r2</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpAreaForCircle&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate area of a hollow circle. <cite>r1</cite> and <cite>r2</cite> are the inner and outer diameters. A solid circle has an inner diameter of 0.

</dd>
<dt id="momentForSegment"><a name="momentForSegment,Float,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">momentForSegment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMomentForSegment&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the moment of inertia for a line segment. Beveling radius is not supported.

</dd>
<dt id="areaForSegment"><a name="areaForSegment,Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">areaForSegment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpAreaForSegment&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the area of a fattened (capsule shaped) line segment.

</dd>
<dt id="momentForPoly"><a name="momentForPoly,Float,cint,ptr.Vect,Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">momentForPoly</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMomentForPoly&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the moment of inertia for a solid polygon shape assuming it's center of gravity is at it's centroid. The offset is added to each vertex.

</dd>
<dt id="areaForPoly"><a name="areaForPoly,cint,ptr.Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">areaForPoly</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">radius</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpAreaForPoly&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the signed area of a polygon. A Clockwise winding gives positive area. This is probably backwards from what you expect, but matches Chipmunk's the winding for poly shapes.

</dd>
<dt id="centroidForPoly"><a name="centroidForPoly,cint,ptr.Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">centroidForPoly</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpCentroidForPoly&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the natural centroid of a polygon.

</dd>
<dt id="momentForBox"><a name="momentForBox,Float,Float,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">momentForBox</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMomentForBox&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the moment of inertia for a solid box.

</dd>
<dt id="momentForBox"><a name="momentForBox,Float,BB"></a><pre><span class="Keyword">proc</span> <span class="Identifier">momentForBox</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">;</span> <span class="Identifier">box</span><span class="Other">:</span> <span class="Identifier">BB</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Float</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpMomentForBox2&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the moment of inertia for a solid box.

</dd>
<dt id="convexHull"><a name="convexHull,cint,ptr.Vect,ptr.Vect,ptr.cint,Float"></a><pre><span class="Keyword">proc</span> <span class="Identifier">convexHull</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">verts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">result</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">first</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">tol</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cpConvexHull&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the convex hull of a given set of points. Returns the count of points in the hull. <cite>result</cite> must be a pointer to a <cite>cpVect</cite> array with at least <cite>count</cite> elements. If <cite>verts</cite> == <cite>result</cite>, then <cite>verts</cite> will be reduced inplace. <cite>first</cite> is an optional pointer to an integer to store where the first vertex in the hull came from (i.e. verts[first] == result[0]) <cite>tol</cite> is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull.

</dd>
<dt id="closestPointOnSegment"><a name="closestPointOnSegment,Vect,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Identifier">closestPointOnSegment</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">cdecl</span><span class="Other">.}</span></pre></dt>
<dd>
Returns the closest point on the line segment ab, to the point p.

</dd>
<dt id=""><a name=",Vect,Float"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">*</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">;</span> <span class="Identifier">s</span><span class="Other">:</span> <span class="Identifier">Float</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span></pre></dt>
<dd>


</dd>
<dt id="+"><a name="+,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">+</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">,</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span></pre></dt>
<dd>


</dd>
<dt id="-"><a name="-,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">-</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">,</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span></pre></dt>
<dd>


</dd>
<dt id="=="><a name="==,Vect,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">==</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v1</span><span class="Other">,</span> <span class="Identifier">v2</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
<dd>


</dd>
<dt id="-"><a name="-,Vect"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">-</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">Vect</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Vect</span></pre></dt>
<dd>


</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2016-05-21 22:52:50 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
